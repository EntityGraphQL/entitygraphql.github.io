{"componentChunkName":"component---src-templates-docs-js","path":"/schema-creation/05-other-data-sources","result":{"data":{"site":{"siteMetadata":{"title":"Entity GraphQL Docs","docsLocation":"https://github.com/lukemurray/EntityGraphQL/tree/master/docs/content"}},"mdx":{"fields":{"id":"e2dc6af4-f58b-5d35-9deb-1a6b529fd913","title":"Other Data Sources","slug":"/schema-creation/05-other-data-sources"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Other Data Sources\",\n  \"metaTitle\": \"Combining multiple data sources in your GraphQL schema - EntityGraphQL\",\n  \"metaDescription\": \"Combining multiple data sources in your GraphQL schema\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"EntityGraphQL lets you add fields that resolve data from other sources other than the core context you created your schema with. This is powerful as it let's you create a single API that brings together multiple data sources into an object graph.\"), mdx(\"h1\", null, mdx(\"inlineCode\", {\n    parentName: \"h1\"\n  }, \"WithService<T>()\"), \" Fields\"), mdx(\"p\", null, \"To use other services in a field we use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"WithService()\"), \" method. EntityGraphQL uses the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IServiceProvider\"), \" you pass on execution to resolve services references in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"WithService()\"), \".\"), mdx(\"p\", null, \"Let's use a service in our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Person\"), \" type example.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"schema.UpdateType<Person>(personType => {\\n    personType.AddField(\\n        \\\"age\\\",\\n        person => WithService((IAgeService srv) => srv.GetAge(person.Dob)),\\n        \\\"Person's age\\\"\\n    );\\n});\\n\\n// Startup.cs\\nservices.AddSingleton<IAgeService, AgeService>();\\n\\n// AgeService.cs\\npublic class AgeService\\n{\\n    public int GetAge(DateTime dob)\\n    {\\n        return (now - dob).TotalYears;\\n    }\\n}\\n\")), mdx(\"p\", null, \"Now when someone requests the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"age\"), \" field on a person the result will be resolved by executing the service \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"srv.GetAge(person.Dob)\"), \". Of course you could calculate the age directly in the field's resolve expression without a service but this demonstrates how to use other services.\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Note as \", mdx(\"inlineCode\", {\n    parentName: \"em\"\n  }, \"WithService\"), \" has a typed return \", mdx(\"inlineCode\", {\n    parentName: \"em\"\n  }, \"WithService<TService, TReturn>\"), \" you can let the compiler figure out the return type by typing the arguments in the \", mdx(\"inlineCode\", {\n    parentName: \"em\"\n  }, \"Func<>\"), \". e.g.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"WithService((IMyService mySer) => mySer.ReturnsInt())\\n// vs\\nWithService<IMyService, int>(mySer => mySer.ReturnsInt())\\n\")), mdx(\"h1\", null, \"Services With Non-Scalar Types\"), mdx(\"p\", null, \"A service can return any type. If it is a complex type you will need to add it to the schema.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"schema.AddField(\\n    \\\"users\\\",\\n    // ctx is the core context we created the schema with. For this field we don't use it\\n    ctx => WithService((IUserService srv) => srv.GetUsers()),\\n    \\\"Get list of users\\\"\\n);\\n\\nschema.AddType<User>(\\\"User\\\", \\\"User information\\\")\\n    .AddAllFields();\\n\\npublic class UserService : IUserService\\n{\\n    public List<User> GetUsers() { ... }\\n}\\n\\npublic class User\\n{\\n    public int Id { get; set; }\\n    public string Email { get; set; }\\n}\\n\")), mdx(\"h1\", null, \"Connecting Back to the Core Context\"), mdx(\"p\", null, \"With the User example above you might want to add fields to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"User\"), \" type that brings in data back from the core context. This let's you create a rich deep object graph for querying.\"), mdx(\"p\", null, \"When joining non-core context types back to the core context you need to use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"WithService()\"), \" again.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"schema.UpdateType<User>(userType => {\\n    userType.AddField(\\n        \\\"tasks\\\",\\n        user => WithService((DemoContext db) => db.Projects.Where(project => project.AssignedToId == user.Id)),\\n        \\\"List of projects assigned to the user\\\"\\n    );\\n});\\n\")), mdx(\"p\", null, \"Now we get query the user and their projects at the same time.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"query {\\n    users {\\n        name\\n        projects {\\n            name\\n            summary\\n        }\\n    }\\n}\\n\")), mdx(\"h1\", null, \"Complex Service Types\"), mdx(\"p\", null, \"If the type you want to define in the schema has data resolved from multiple different methods inn your service you can create a service type class.\"), mdx(\"p\", null, \"Let's say we want a root-level \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"metrics\"), \" field where each sub-field uses a service to load the value. If someone only queries 1 of the fields you don't want all of them to resolve. To achieve this we can do the following.\"), mdx(\"p\", null, \"Define a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Metrics\"), \" class that uses a service to provide the functionality.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"public class Metrics\\n{\\n    private IMetricService m;\\n    public Metrics(IMetricService m)\\n    {\\n        this.m = m;\\n    }\\n    public int TotalWebhooks => m.TotalWebhooks();\\n    public int TotalApiKeys => m.TotalApiKeys();\\n    public int TotalUsers => m.TotalUsers();\\n}\\n\")), mdx(\"p\", null, \"No we can add the types & fields to GraphQL.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"// add the type\\nvar metricsType = adminSchema.AddType<Metrics>(\\\"Metrics\\\", \\\"Contains summary metrics\\\")\\n    .AddAllFields();\\n\\n// add the root-level field\\nadminSchema.AddField(\\\"metrics\\\",\\n    db => WithService((IMetricService m) => new Metrics(m)),\\n    \\\"Return summary metrics\\\",\\n    metricsType.Name);\\n}\\n\")), mdx(\"p\", null, \"Now we can query\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"{\\n    metrics { totalWebhooks }\\n}\\n\")), mdx(\"p\", null, \"To demonstrate that only the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"m.TotalWebhooks()\"), \" method is called here is what is produced as the .NET expression.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-c#\"\n  }, \"(MyDbContext db, IMetricService m) => {\\n    var context = new Metric(m);\\n    return new\\n    {\\n        totalWebhooks = context.TotalWebhooks,\\n    }\\n};\\n\")), mdx(\"p\", null, \"You'll see none of the other fields are in the expression and therefore the methods will not execute.\"));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#withservicet-fields","title":"WithService<T>() Fields"},{"url":"#services-with-non-scalar-types","title":"Services With Non-Scalar Types"},{"url":"#connecting-back-to-the-core-context","title":"Connecting Back to the Core Context"},{"url":"#complex-service-types","title":"Complex Service Types"}]},"parent":{"relativePath":"schema-creation/05-other-data-sources.md"},"frontmatter":{"metaTitle":"Combining multiple data sources in your GraphQL schema - EntityGraphQL","metaDescription":"Combining multiple data sources in your GraphQL schema"}},"allMdx":{"edges":[{"node":{"fields":{"slug":"/authorization","title":"Authorization"}}},{"node":{"fields":{"slug":"/","title":"Entity GraphQL"}}},{"node":{"fields":{"slug":"/entity-framework","title":"Entity Framework"}}},{"node":{"fields":{"slug":"/integration","title":"Integration"}}},{"node":{"fields":{"slug":"/schema-creation/01-mutations","title":"Mutations"}}},{"node":{"fields":{"slug":"/schema-creation","title":"Schema Creation"}}},{"node":{"fields":{"slug":"/schema-creation/02-fields","title":"Field Arguments"}}},{"node":{"fields":{"slug":"/schema-creation/04-directives","title":"Directives"}}},{"node":{"fields":{"slug":"/schema-creation/05-other-data-sources","title":"Other Data Sources"}}},{"node":{"fields":{"slug":"/field-extensions","title":"Field Extensions"}}},{"node":{"fields":{"slug":"/field-extensions/02-filtering","title":"Filtering"}}},{"node":{"fields":{"slug":"/field-extensions/01-paging","title":"Paging"}}},{"node":{"fields":{"slug":"/introduction","title":"Introduction"}}},{"node":{"fields":{"slug":"/schema-creation/06-naming","title":"Note on Naming"}}},{"node":{"fields":{"slug":"/field-extensions/04-custom-extensions","title":"Custom Extensions"}}},{"node":{"fields":{"slug":"/getting-started","title":"Getting Started"}}},{"node":{"fields":{"slug":"/schema-creation/03-types","title":"Other Types"}}},{"node":{"fields":{"slug":"/field-extensions/03-sorting","title":"Sorting"}}}]}},"pageContext":{"id":"e2dc6af4-f58b-5d35-9deb-1a6b529fd913"}},"staticQueryHashes":["2619113677","3706406642","417421954"]}