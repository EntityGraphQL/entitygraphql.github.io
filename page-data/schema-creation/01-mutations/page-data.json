{"componentChunkName":"component---src-templates-docs-js","path":"/schema-creation/01-mutations","result":{"data":{"site":{"siteMetadata":{"title":"Entity GraphQL Docs","docsLocation":"https://github.com/lukemurray/EntityGraphQL/tree/master/docs/content"}},"mdx":{"fields":{"id":"ee1a1997-94e9-55c2-817a-0ae99e6c0a31","title":"Mutations","slug":"/schema-creation/01-mutations"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Mutations\",\n  \"metaTitle\": \"Adding mutations to your schema - EntityGraphQL\",\n  \"metaDescription\": \"Add mutations to your GraphQL schema\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Mutations are GraphQLs way of allowing you to make modifications to your data.\"), mdx(\"p\", null, \"Read more about GraphQL mutations \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://graphql.org/learn/queries/#mutations\"\n  }, \"here\"), \".\"), mdx(\"p\", null, \"In EntityGraphQL mutations are just .NET methods and there are a few ways to add or define them.\"), mdx(\"h1\", null, \"Adding Mutations from a class\"), mdx(\"p\", null, \"You can keep related mutations in a class and marked each mutation method with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[GraphQLMutation]\"), \" attribute and use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"schema.AddMutationsFrom()\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"public class PeopleMutations\\n{\\n    [GraphQLMutation(\\\"Add a new person to the system\\\")]\\n    public Expression<Func<DemoContext, Person>> AddNewPerson(DemoContext db, AddPersonArgs args)\\n    {\\n        var person = new Person\\n        {\\n            FirstName = args.FirstName,\\n            LastName = args.LastName,\\n        };\\n        db.People.Add(person);\\n        db.SaveChanges();\\n\\n        return (ctx) => ctx.People.First(p => p.Id == person.Id);\\n    }\\n}\\n\\n[MutationArguments]\\npublic class AddPersonArgs\\n{\\n    public string FirstName { get; set; }\\n    public string LastName { get; set; }\\n}\\n\")), mdx(\"p\", null, \"Now we can add it to the schema in the following ways:\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Register the mutation class\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"schema.AddMutationsFrom<PeopleMutations>();\\n\")), mdx(\"p\", null, \"EntityGraphQL will find all methods marked as \", \"[GraphQLMutation]\", \" on the PeopleMuations type and add them as mutations.\"), mdx(\"p\", null, \"When calling the mutuation it will ask the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ServiceProvider\"), \" for an instance of the class allowing for dependency injection at the constructor level, if that fails to return a result it will use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Activator.CreateInstance\"), \".\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"As an interface/base class generic argument\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"schema.AddMutationsFrom<IMutationClass>);\\n\")), mdx(\"p\", null, \"EntityGraphQL actually looks for all types (in the same assembly) that implement the interface or base class, meaning you could mark all your mutation classes with a marker interface like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IMutationClass\"), \" and they will all be registered with one line\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Providing an Instance of the mutation class\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"schema.AddMutationsFrom(new PeopleMutations());\\n\")), mdx(\"p\", null, \"EntityGraphQL will find all methods marked as \", \"[GraphQLMutation]\", \" on the PeopleMuations type and add them as mutations.\"), mdx(\"p\", null, \"When calling the mutation it will use the instance of the PeopleMuations you provided.\"), mdx(\"p\", null, \"This method is considered obsolete and will be removed in a future version. We suggest you use one of the above methods and utilse the ServiceProvider to register your mutation classes with your desired lifetime.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Now we can add people!\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"mutation {\\n    addNewPerson(firstName: \\\"Bill\\\", lastName: \\\"Murray\\\") {\\n        id\\n        fullName\\n    }\\n}\\n\")), mdx(\"p\", null, \"Above we use our mutation to add a person and select their \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fullName\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"id\"), \" in the result.\"), mdx(\"h1\", null, \"AddMutationsFrom method arguments\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"  void AddMutationsFrom<TType>(TType? mutationClassInstance =  null, bool autoAddInputTypes = false, bool addNonAttributedMethods = false) where TType : class;\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"mutationClassInstance\"), \"\\nInstance of the mutation class, if not provided then EntityGraphQL will try obtain one from the ServiceProvider or fallback to Activator.CreateInstance\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Obsolete\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"autoAddInputTypes\"), \"\\nIf true, any class types seen in the mutation argument properties will be added to the schema\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"addNonAttributedMethods\"), \"\\nIf true, EntityGraphQL will add any method in the mutation class as a mutation without needing the \", \"[GraphQLMutation]\", \" attribute. Methods must be \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Public\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"not inherited\"), \" but can be either \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"static\"), \" or \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"instance\"), \".\"), mdx(\"h1\", null, \"Adding a Mutations as a Delegate\"), mdx(\"p\", null, \"You can also add individual mutation methods to the mutation type as delegates or inline methods.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"public class PeopleMutations\\n{\\n    public class void Configure(ISchemaProvider<DemoContext> schema)\\n    {\\n        schema.Mutation().Add(\\\"peopleMutations\\\", \\\"Add a new person to the system\\\", AddNewPerson);\\n\\n        schema.Mutation().Add(\\\"peopleMutations\\\", \\\"Do somethign else\\\", (OtherArgs args) => {\\n            // ... mutate logic here\\n        });\\n    }\\n\\n    public Expression<Func<DemoContext, Person>> AddNewPerson(DemoContext db, AddPersonArgs args)\\n    {\\n        var person = new Person\\n        {\\n            FirstName = args.FirstName,\\n            LastName = args.LastName,\\n        };\\n        db.People.Add(person);\\n        db.SaveChanges();\\n\\n        return (ctx) => ctx.People.First(p => p.Id == person.Id);\\n    }\\n}\\n\")), mdx(\"h1\", null, \"Why Use \", mdx(\"inlineCode\", {\n    parentName: \"h1\"\n  }, \"Expression\"), \" Return Type\"), mdx(\"p\", null, \"Note the return signature above and the result we return is an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Expression<Func<>>\"), \" that selects the person we just modified.\"), mdx(\"p\", null, \"Just like in queries, if the mutation field returns an object type, you can ask for nested fields. This can be useful for fetching the new state of an object after an update.\"), mdx(\"p\", null, \"One API user may ask for the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"id\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"mutation {\\n    addNewPerson(firstName: \\\"Bill\\\", lastName: \\\"Murray\\\") {\\n        id\\n    }\\n}\\n\")), mdx(\"p\", null, \"And another might want more\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"mutation {\\n    addNewPerson(firstName: \\\"Bill\\\", lastName: \\\"Murray\\\") {\\n        id firstName fullName\\n    }\\n}\\n\")), mdx(\"p\", null, \"As you don't know which fields an API user will request, you therefore don't know what data to load into memory and return in that object. As EntityGraphQL will execute the field selection against the returned object.\"), mdx(\"p\", null, \"Using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Expression<Func<>>\"), \" as a return type allows EntityGraphQL to build an expression across the whole schema graph. An example of the expression result built for the above mutation.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"(DemoContext ctx) => ctx.People\\n    .Where(p => p.Id == <id_from_variable>)\\n    .Select(p => new {\\n        id = p.Id,\\n        firstName = p.FirstName,\\n        fullName = $\\\"{p.FirstName} {p.LastName}\\\"\\n    })\\n    .First()\\n\")), mdx(\"p\", null, \"This means we have access to the full schema graph from the core context of the schema and if you are using an ORM like Entity Framework it will load the requested data for you.\"), mdx(\"h1\", null, \"Dependencies Injection & Services\"), mdx(\"p\", null, \"You likely want to access some services in your mutations. EntityGraphQL supports dependency injection. When you execute a query make sure you pass in an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IServiceProvider\"), \". Here is an example with ASP.NET.\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Note if you use \", mdx(\"a\", {\n    parentName: \"em\",\n    \"href\": \"https://www.nuget.org/packages/EntityGraphQL.AspNet\"\n  }, \"EntityGraphQL.AspNet\"), \" the registered \", mdx(\"inlineCode\", {\n    parentName: \"em\"\n  }, \"IServiceProvider\"), \" is provided.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"var results = _schemaProvider.ExecuteRequest(query, demoContext, HttpContext.RequestServices, null);\\n\")), mdx(\"p\", null, \"EntityGraphQL will use that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IServiceProvider\"), \" to resolve any services when calling your mutation method. All you need to do is make sure the service is registered and include it in the method signature of the mutation. This includes both constructor arguments (when a mutation class instance is not provided) and method arguments for the specific mutation.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"// in Startup.cs\\nservices.AddSingleton<IDemoService, DemoService>();\\n\\n// your mutation method\\n[GraphQLMutation(\\\"Add a new person to the system)]\\npublic Expression<Func<DemoContext, Person>> AddNewPerson(DemoContext db, AddPersonArgs args, IDemoService demoService)\\n{\\n    // do something cool with demoService\\n\\n    return (ctx) => ctx.People.First(p => p.Id == person.Id);\\n}\\n\")), mdx(\"p\", null, \"Later we'll learn how to access services within query fields of the schema.\"));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#adding-mutations-from-a-class","title":"Adding Mutations from a class"},{"url":"#addmutationsfrom-method-arguments","title":"AddMutationsFrom method arguments"},{"url":"#adding-a-mutations-as-a-delegate","title":"Adding a Mutations as a Delegate"},{"url":"#why-use-expression-return-type","title":"Why Use Expression Return Type"},{"url":"#dependencies-injection--services","title":"Dependencies Injection & Services"}]},"parent":{"relativePath":"schema-creation/01-mutations.md"},"frontmatter":{"metaTitle":"Adding mutations to your schema - EntityGraphQL","metaDescription":"Add mutations to your GraphQL schema"}},"allMdx":{"edges":[{"node":{"fields":{"slug":"/field-extensions","title":"Field Extensions"}}},{"node":{"fields":{"slug":"/authorization","title":"Authorization"}}},{"node":{"fields":{"slug":"/getting-started","title":"Getting Started"}}},{"node":{"fields":{"slug":"/integration","title":"Tool Integration"}}},{"node":{"fields":{"slug":"/","title":"Entity GraphQL"}}},{"node":{"fields":{"slug":"/entity-framework","title":"Entity Framework"}}},{"node":{"fields":{"slug":"/introduction","title":"Introduction"}}},{"node":{"fields":{"slug":"/serialization-naming/newtonsoft-json","title":"Using Newtonsoft.Json"}}},{"node":{"fields":{"slug":"/serialization-naming","title":"Serialization & Field Naming"}}},{"node":{"fields":{"slug":"/schema-creation/01-mutations","title":"Mutations"}}},{"node":{"fields":{"slug":"/validation","title":"Validation"}}},{"node":{"fields":{"slug":"/schema-creation/03-types","title":"Other Types"}}},{"node":{"fields":{"slug":"/schema-creation/04-directives","title":"Directives"}}},{"node":{"fields":{"slug":"/schema-creation/02-fields","title":"Field Arguments"}}},{"node":{"fields":{"slug":"/schema-creation","title":"Schema Creation"}}},{"node":{"fields":{"slug":"/field-extensions/01-paging","title":"Paging"}}},{"node":{"fields":{"slug":"/schema-creation/05-other-data-sources","title":"Other Data Sources"}}},{"node":{"fields":{"slug":"/field-extensions/02-filtering","title":"Filtering"}}},{"node":{"fields":{"slug":"/field-extensions/03-sorting","title":"Sorting"}}},{"node":{"fields":{"slug":"/field-extensions/04-custom-extensions","title":"Custom Extensions"}}}]}},"pageContext":{"id":"ee1a1997-94e9-55c2-817a-0ae99e6c0a31"}},"staticQueryHashes":["2619113677","3706406642","417421954"]}