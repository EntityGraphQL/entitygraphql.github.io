{"componentChunkName":"component---src-templates-docs-js","path":"/schema-creation/03-types","result":{"data":{"site":{"siteMetadata":{"title":"Entity GraphQL Docs","docsLocation":"https://github.com/lukemurray/EntityGraphQL/tree/master/docs/content"}},"mdx":{"fields":{"id":"61b197e8-9cee-5b3d-8344-2e31410fcdab","title":"Other Types","slug":"/schema-creation/03-types"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Other Types\",\n  \"metaTitle\": \"Advanced types - EntityGraphQL\",\n  \"metaDescription\": \"Advanced types in EntityGraphQL\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"So far we've only been dealing with GraphQL Object types. Types that are part of the object graph and have fields. These are the most common type in our schema, but lets look at the other types we can use.\"), mdx(\"h1\", null, \"Scalar Types\"), mdx(\"p\", null, \"We learnt previous that the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://graphql.org/learn/schema/#scalar-types\"\n  }, \"GraphQL spec\"), \" defines the following built in scalar types.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Int: A signed 32\\u2010bit integer.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Float: A signed double-precision floating-point value.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"String: A UTF\\u20108 character sequence.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Boolean: true or false.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"ID: The ID scalar type represents a unique identifier. The ID type is serialized in the same way as a String; however, defining it as an ID signifies that it is not intended to be human\\u2010readable.\")), mdx(\"p\", null, \"We of course can add our own. Scalar types help you describe the data in you schema. Unlike Object types they don't have fields you can query, they result in data. Ultimately you are likely serializing the data to JSON for transport.\"), mdx(\"p\", null, \"Adding a scalar type tells EntityGraphQL that the object should just be returned. i.e. there is no selection available on it. A good example is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DateTime\"), \". We just want to return the  \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DateTime\"), \" value. Not have it as an Object type where you could select certain properties from it (Although that is valid).\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"schema.AddScalarType<DateTime>(\\\"DateTime\\\", \\\"Represents a date and time.\\\");\\n\")), mdx(\"h1\", null, \"Enum Types\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://graphql.org/learn/schema/#enumeration-types\"\n  }, \"Enum types\"), \" are just like you'd expect. It let's API consumers know that a field can be only 1 of a set of values.\"), mdx(\"p\", null, \"With our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Person\"), \" example we could add a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gender\"), \" enum.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"[JsonConverter(typeof(StringEnumConverter))]\\npublic enum Gender {\\n    Female,\\n    Male,\\n    NotSpecified\\n}\\n\\n// building our schema\\nschema.AddEnum(\\\"Gender\\\", typeof(Gender), \\\"A persons Gender\\\");\\n\")), mdx(\"p\", null, \"The GraphQL schema produce from this helps document and describe the data model to API uses. Example GraphQL schema below\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"enum Gender {\\n    Female\\n    Male\\n    NotSpecified\\n}\\n\\ntype Person {\\n    firstName: String\\n    lastName: String\\n    gender: Gender\\n}\\n\")), mdx(\"h1\", null, \"Input Types\"), mdx(\"p\", null, \"We've seen passing scalar values, like enums, numbers or strings, as arguments into a field. \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://graphql.org/learn/schema/#input-types\"\n  }, \"Input types\"), \" allow us to define complex types that can be used as an argument. This is particularly valuable in the case of mutations, where you might want to pass in a whole object to be created.\"), mdx(\"p\", null, \"Input types differ to regular Object types largely because they can't have arguments on their fields. There are just a data object. As described in the spec\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"The fields on an input object type can themselves refer to input object types, but you can't mix input and output types in your schema. Input object types also can't have arguments on their fields.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"public class PeopleMutations\\n{\\n    [GraphQLMutation(\\\"Add a new person to the system)]\\n    public Expression<Func<DemoContext, Person>> AddNewPerson(DemoContext db, AddPersonArgs args)\\n    {\\n        var person = new Person\\n        {\\n            FirstName = args.PersonInput.FirstName,\\n            LastName = args.PersonInput.LastName,\\n        };\\n        db.People.Add(person);\\n        db.SaveChanges();\\n\\n        return (ctx) => ctx.People.First(p => p.Id == person.Id);\\n    }\\n}\\n\\n[MutationArguments]\\npublic class AddPersonArgs\\n{\\n    public PersonInput PersonInput { get; set; }\\n}\\n\\npublic class PersonInput\\n{\\n    public string FirstName { get; set; }\\n    public string LastName { get; set; }\\n}\\n\\n\\n// creating our schema\\nschema.AddInputType<PersonInput>(\\\"PersonInput\\\", \\\"New person data\\\")\\n    .AddAllFields();\\n\")), mdx(\"p\", null, \"You could of course use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Person\"), \" class from your data model directly and be selective about the fields you add to the GraphQL schema.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"public class PeopleMutations\\n{\\n    [GraphQLMutation(\\\"Add a new person to the system)]\\n    public Expression<Func<DemoContext, Person>> AddNewPerson(DemoContext db, AddPersonArgs args)\\n    {\\n        db.People.Add(args.PersonInput);\\n        db.SaveChanges();\\n        return (ctx) => ctx.People.First(p => p.Id == person.Id);\\n    }\\n}\\n\\n[MutationArguments]\\npublic class AddPersonArgs\\n{\\n    public Person PersonInput { get; set; }\\n}\\n\\n// creating our schema\\nvar type = schema.AddInputType<Person>(\\\"PersonInput\\\", \\\"New person data\\\")\\ntype.AddField(\\\"firstName\\\", p => p.FirstName, \\\"First name);\\ntype.AddField(\\\"lastName\\\", p => p.LastName, \\\"Last name);\\n\")), mdx(\"p\", null, \"You can also use complex types in field arguments.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"public class FilterInput\\n{\\n    public string FirstName { get; set; }\\n    public string LastName { get; set; }\\n}\\n\\nschema.AddField(\\n    \\\"people\\\",\\n    new {\\n        filter = (FilterInput)null\\n    },\\n    (ctx, args) => ctx.People\\n        .WhereWhen(p => p.FistName == args.filter.firstName, !string.IsNullOrEmpty(args.filter.firstName))\\n        .WhereWhen(p => p.LastName == args.filter.lastName, !string.IsNullOrEmpty(args.filter.lastName)),\\n    \\\"List of people optionally filtered by a first and/or last name\\\"\\n);\\n\\nschema.AddInputType<FilterInput>(\\\"FilterInput\\\", \\\"Filter data for people\\\")\\n    .AddAllFields();\\n\")), mdx(\"p\", null, \"The larger impact of these choices can be seen in the resulting schema and use of the API.\"), mdx(\"p\", null, \"With scalar arguments.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"POST localhost:5000/graphql\\n    {\\n    \\\"query\\\": \\\"mutation AddPerson($firstName: String!, $lastName: String!) {\\n        addNewPerson(firstName: $firstName, lastName: $lastName) { id }\\n    }\\\",\\n    \\\"variables\\\": {\\n        \\\"firstName\\\": \\\"Bill\\\",\\n        \\\"lastName\\\": \\\"Murray\\\"\\n    }\\n}\\n\")), mdx(\"p\", null, \"With an input type argument\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"POST localhost:5000/graphql\\n{\\n    \\\"query\\\": \\\"mutation AddPerson($person: PersonInput!) {\\n        addNewPerson(personInput: $person) { id }\\n    }\\\",\\n    \\\"variables\\\": {\\n        \\\"personInput\\\": {\\n            \\\"firstName\\\": \\\"Bill\\\",\\n            \\\"lastName\\\": \\\"Murray\\\"\\n        }\\n    }\\n}\\n\")), mdx(\"h1\", null, \"Lists and Non-Null\"), mdx(\"p\", null, \"GraphQL defines \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://graphql.org/learn/schema/#lists-and-non-null\"\n  }, \"type modifiers\"), \" specifically for declaring that a is a list or can not be \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"null\"), \". In a schema these are \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[T]\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"!\"), \". For example a GraphQL schema might have the following.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"enum Gender {\\n    Female\\n    Male\\n    NotSpecified\\n}\\n\\ntype Person {\\n    firstName: String!\\n    lastName: String!\\n    gender: Gender!\\n    friends: [Person]\\n}\\n\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"!\"), \" on all the fields tells API users that those fields will not be \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"null\"), \". And the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[]\"), \" around the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Person\"), \" type on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"friends\"), \" field types the API users that the field returns a list of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Person\"), \" objects.\"), mdx(\"p\", null, \"EntityGraphQL will automatically figure out fields that return lists based on if the resolve expression returns an array or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IEnumerable<T>\"), \".\"), mdx(\"p\", null, \"Similarly EntityGraphQL will mark non-nullable .NET types as non-null in thr GraphQL schema. If you need to change that you can use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"field.IsNullable(bool)\"), \".\"), mdx(\"p\", null, \"Lets say we know a person's first and last name will never be null.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"var type = schema.AddInputType<Person>(\\\"PersonInput\\\", \\\"New person data\\\")\\ntype.AddField(\\\"firstName\\\", p => p.FirstName, \\\"First name).IsNullable(false);\\ntype.AddField(\\\"lastName\\\", p => p.LastName, \\\"Last name).IsNullable(false);\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#scalar-types","title":"Scalar Types"},{"url":"#enum-types","title":"Enum Types"},{"url":"#input-types","title":"Input Types"},{"url":"#lists-and-non-null","title":"Lists and Non-Null"}]},"parent":{"relativePath":"schema-creation/03-types.md"},"frontmatter":{"metaTitle":"Advanced types - EntityGraphQL","metaDescription":"Advanced types in EntityGraphQL"}},"allMdx":{"edges":[{"node":{"fields":{"slug":"/authorization","title":"Authorization"}}},{"node":{"fields":{"slug":"/","title":"Entity GraphQL"}}},{"node":{"fields":{"slug":"/entity-framework","title":"Entity Framework"}}},{"node":{"fields":{"slug":"/integration","title":"Integration"}}},{"node":{"fields":{"slug":"/schema-creation/01-mutations","title":"Mutations"}}},{"node":{"fields":{"slug":"/schema-creation","title":"Schema Creation"}}},{"node":{"fields":{"slug":"/schema-creation/02-fields","title":"Field Arguments"}}},{"node":{"fields":{"slug":"/schema-creation/04-directives","title":"Directives"}}},{"node":{"fields":{"slug":"/schema-creation/05-other-data-sources","title":"Other Data Sources"}}},{"node":{"fields":{"slug":"/field-extensions","title":"Field Extensions"}}},{"node":{"fields":{"slug":"/field-extensions/02-filtering","title":"Filtering"}}},{"node":{"fields":{"slug":"/field-extensions/01-paging","title":"Paging"}}},{"node":{"fields":{"slug":"/introduction","title":"Introduction"}}},{"node":{"fields":{"slug":"/schema-creation/06-naming","title":"Note on Naming"}}},{"node":{"fields":{"slug":"/field-extensions/04-custom-extensions","title":"Custom Extensions"}}},{"node":{"fields":{"slug":"/getting-started","title":"Getting Started"}}},{"node":{"fields":{"slug":"/schema-creation/03-types","title":"Other Types"}}},{"node":{"fields":{"slug":"/field-extensions/03-sorting","title":"Sorting"}}}]}},"pageContext":{"id":"61b197e8-9cee-5b3d-8344-2e31410fcdab"}},"staticQueryHashes":["2619113677","3706406642","417421954"]}