{"componentChunkName":"component---src-templates-docs-js","path":"/field-extensions/02-filtering","result":{"data":{"site":{"siteMetadata":{"title":"Entity GraphQL Docs","docsLocation":"https://github.com/lukemurray/EntityGraphQL/tree/master/docs/content"}},"mdx":{"fields":{"id":"603d711c-f2bb-56da-bcd4-209f3e4c8f4d","title":"Filtering","slug":"/field-extensions/02-filtering"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Filtering\",\n  \"metaTitle\": \"Add filtering to your fields - EntityGraphQL\",\n  \"metaDescription\": \"Add filtering to your fields\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"To quickly add filtering capabilities to your collection fields use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UseFilter()\"), \" field extension.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"schema.ReplaceField(\\\"people\\\",\\n    ctx => ctx.People,\\n    \\\"Return a list of people. Optional filtered\\\")\\n    .UseFilter();\\n\")), mdx(\"p\", null, \"If you are using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SchemaBuilder.FromObject\"), \" you can use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UseFilterAttribute\"), \" on your collection properties.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"public class DemoContext : DbContext\\n{\\n    [UseFilter]\\n    public DbSet<Movie> Movies { get; set; }\\n    [UseFilter]\\n    public DbSet<Person> People { get; set; }\\n    [UseFilter]\\n    public DbSet<Actor> Actors { get; set; }\\n}\\n\")), mdx(\"p\", null, \"This field extension can only be used on a field that has a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Resolve\"), \" expression that is assignable to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IEnumerable\"), \" - I.e. collections. The extension adds an argument called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"filter: String\"), \".\"), mdx(\"p\", null, \"Note: When using with the paging or sort extensions ensure you call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UseFilter\"), \" before both others. If you are using the attribute, then ensure the Filter attribute comes before the other attributes.\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"filter\"), \" argument takes a string that will be compiled to an expression and inserted into a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Where()\"), \" call. The expression is compiled against your schema and the context is the type of elements in the collection.\"), mdx(\"p\", null, \"For example, given \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ctx => ctx.People\"), \" returns a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IEnumerable<Person>\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Person\"), \" is defined as:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"public class Person\\n{\\n    public uint Id { get; set; }\\n    public string FirstName { get; set; }\\n    public string LastName { get; set; }\\n    public DateTime Dob { get; set; }v\\n    public List<Actor> ActorIn { get; set; }\\n    public List<Writer> WriterOf { get; set; }\\n    public List<Movie> DirectorOf { get; set; }\\n    public DateTime? Died { get; set; }\\n    public bool IsDeleted { get; set; }\\n}\\n\")), mdx(\"p\", null, \"We can write some filter expressions like so:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"{\\n    people(filter: \\\"id == 12 || id == 10\\\") {\\n        firstName\\n    }\\n}\\n\\n{\\n    deletedPeople: people(filter: \\\"isDeleted == true\\\") {\\n        firstName\\n    }\\n}\\n\\n{\\n    people(filter: \\\"dob > \\\\\\\"2010-08-11T00:00:00\\\\\\\" && isDeleted == false\\\") {\\n        firstName\\n    }\\n}\\n\")), mdx(\"p\", null, \"The expression language supports the following constants:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Booleans - \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"true\"), \" & \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"false\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Integers - e.g. \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"2\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"-8\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Floats - e.g. \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0.2\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"-8.3\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"null\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Strings - \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"\\\"within double quotes\\\"\"))), mdx(\"p\", null, \"The expression language supports the following operators:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"-\"), \" - Subtraction\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"+\"), \" - Addition\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"*\"), \" - Multiply\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"/\"), \" - Divide\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"%\"), \" - Mod\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"^\"), \" - Power\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"==\"), \" - Equals\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"<=\"), \" - Less than or equal to\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \">=\"), \" - Greater than or equal to\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"<\"), \" - Less than\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \">\"), \" - Greater than\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"or\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"||\"), \" - Or\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"and\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"&&\"), \" - And\")), mdx(\"p\", null, \"The expression language supports the follow methods:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"List.where(filter)\"), \", or \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"List.filter(filter)\"), \" - Filter the list\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"List.any(filter)\"), \" - Return \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"true\"), \" if any of the items in the list match the filter. Otherwise \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"false\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"List.first(filter?)\"), \" - Return the first item from a list. Optionally by a filter\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"List.last(filter?)\"), \" - Return the last item from a list. Optionally by a filter\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"List.take(int)\"), \" - Return the first \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"x\"), \" items\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"List.skip(int)\"), \" - Return the items after \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"x\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"List.count(filter?)\"), \" - Return the count of a list. Optionally counting items that match a filter\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"List.orderBy(field)\"), \" - Order the list by a given field\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"List.orderByDesc(field)\"), \" - Order the list in reverse by a given field\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{},"parent":{"relativePath":"field-extensions/02-filtering.md"},"frontmatter":{"metaTitle":"Add filtering to your fields - EntityGraphQL","metaDescription":"Add filtering to your fields"}},"allMdx":{"edges":[{"node":{"fields":{"slug":"/authorization","title":"Authorization"}}},{"node":{"fields":{"slug":"/entity-framework","title":"Entity Framework"}}},{"node":{"fields":{"slug":"/integration","title":"Tool Integration"}}},{"node":{"fields":{"slug":"/getting-started","title":"Getting Started"}}},{"node":{"fields":{"slug":"/field-extensions","title":"Field Extensions"}}},{"node":{"fields":{"slug":"/","title":"Entity GraphQL"}}},{"node":{"fields":{"slug":"/introduction","title":"Introduction"}}},{"node":{"fields":{"slug":"/schema-creation","title":"Schema Creation"}}},{"node":{"fields":{"slug":"/serialization-naming","title":"Serialization & Field Naming"}}},{"node":{"fields":{"slug":"/validation","title":"Validation"}}},{"node":{"fields":{"slug":"/serialization-naming/newtonsoft-json","title":"Using Newtonsoft.Json"}}},{"node":{"fields":{"slug":"/schema-creation/01-mutations","title":"Mutations"}}},{"node":{"fields":{"slug":"/schema-creation/02-fields","title":"Field Arguments"}}},{"node":{"fields":{"slug":"/schema-creation/04-directives","title":"Directives"}}},{"node":{"fields":{"slug":"/schema-creation/05-other-data-sources","title":"Other Data Sources"}}},{"node":{"fields":{"slug":"/schema-creation/03-types","title":"Other Types"}}},{"node":{"fields":{"slug":"/field-extensions/01-paging","title":"Paging"}}},{"node":{"fields":{"slug":"/field-extensions/02-filtering","title":"Filtering"}}},{"node":{"fields":{"slug":"/field-extensions/04-custom-extensions","title":"Custom Extensions"}}},{"node":{"fields":{"slug":"/field-extensions/03-sorting","title":"Sorting"}}}]}},"pageContext":{"id":"603d711c-f2bb-56da-bcd4-209f3e4c8f4d"}},"staticQueryHashes":["2619113677","3706406642","417421954"]}