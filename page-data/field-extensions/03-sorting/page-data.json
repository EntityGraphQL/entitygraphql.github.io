{
    "componentChunkName": "component---src-templates-docs-js",
    "path": "/field-extensions/03-sorting",
    "result": {"data":{"site":{"siteMetadata":{"title":"Entity GraphQL Docs","docsLocation":"https://github.com/lukemurray/EntityGraphQL/tree/master/docs/content"}},"mdx":{"fields":{"id":"56ba909b-2e10-5ccc-a0dd-497566eea214","title":"Sorting","slug":"/field-extensions/03-sorting"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Sorting\",\n  \"metaTitle\": \"Add sorting to your collection fields - EntityGraphQL\",\n  \"metaDescription\": \"Add sorting to your collection fields\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Being able to sort or order you collections as you query them can be very powerful, especially when paired with paging. To easily add sorting functionality to your collection fields use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UseSort()\"), \" field extension.\"), mdx(\"p\", null, \"Note: When using with one of the paging extensions ensure you call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UseSort\"), \" first. If you are using the attribute, then ensure the Sort attribute comes before the paging attribute. If using with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UseFilter\"), \" extensions, call filter first. Filter -> Sort -> Paging.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"schema.ReplaceField(\\\"people\\\",\\n    ctx => ctx.People,\\n    \\\"Return a list of people. Optional sorted\\\")\\n    .UseSort();\\n\")), mdx(\"p\", null, \"If you are using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SchemaBuilder.FromObject\"), \" you can use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UseSortAttribute\"), \" on your collection properties.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"public class DemoContext : DbContext\\n{\\n    [UseSort]\\n    public DbSet<Movie> Movies { get; set; }\\n    [UseSort]\\n    public DbSet<Person> People { get; set; }\\n    [UseSort]\\n    public DbSet<Actor> Actors { get; set; }\\n}\\n\")), mdx(\"p\", null, \"This field extension can only be used on a field that has a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Resolve\"), \" expression that is assignable to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IEnumerable\"), \" - I.e. collections. The extension adds an argument called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sort: [<field_name>SortInput]\"), \". For example \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"PeopleSortInput\"), \". The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SortInput\"), \" type will have nullable fields for each scalar type in the collection element type. You set which fields you want to use for sorting. Following the above \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"people\"), \" field with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Person\"), \" class defined as:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"public class Person\\n{\\n    public uint Id { get; set; }\\n    public string FirstName { get; set; }\\n    public string LastName { get; set; }\\n    public DateTime Dob { get; set; }v\\n    public List<Actor> ActorIn { get; set; }\\n    public List<Writer> WriterOf { get; set; }\\n    public List<Movie> DirectorOf { get; set; }\\n    public DateTime? Died { get; set; }\\n    public bool IsDeleted { get; set; }\\n}\\n\")), mdx(\"p\", null, \"The GraphQL type will be define like:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"input PeopleSortInput\\n{\\n    id: SortDirectionEnum\\n    firstName: SortDirectionEnum\\n    lastName: SortDirectionEnum\\n    dob: SortDirectionEnum\\n    died: SortDirectionEnum\\n    isDeleted: SortDirectionEnum\\n}\\n\\nenum SortDirectionEnum {\\n    ASC\\n    DESC\\n}\\n\")), mdx(\"p\", null, \"To sort the collection you set the fields with a direction:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"{\\n    people(sort: [{lastName: DESC}]) { lastName }\\n}\\n\\n{\\n    people(sort: [{dob: ASC}]) { lastName }\\n}\\n\")), mdx(\"p\", null, \"Multiple fields is supported and are taken as ordered\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"{\\n    people(sort: [{dob: ASC}, {lastName: DESC}, {firstName: ASC}]) { lastName }\\n}\\n\")), mdx(\"h1\", null, \"Default sort\"), mdx(\"p\", null, \"You can set a default sort to be applied if there are no sort arguments passed in the query.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"schema.ReplaceField(\\\"people\\\",\\n    ctx => ctx.People,\\n    \\\"Return a list of people. Optional sorted\\\")\\n    .UseSort((Person person) => person.Dob, SortDirectionEnum.DESC);\\n\")), mdx(\"h1\", null, \"Choosing the sort fields\"), mdx(\"p\", null, \"If you use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UseSort()\"), \" method (not the attribute) you can pass in an expression which tells the extension which fields to set in the input type. Make sure you use the correct type for the fields collection.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"schema.ReplaceField(\\\"people\\\",\\n    ctx => ctx.People,\\n    \\\"Return a list of people. Optional sorted\\\")\\n    .UseSort((Person person) => new\\n    {\\n        person.Dob,\\n        person.LastName\\n    });\\n\")), mdx(\"p\", null, \"This will result in only 2 options for sorting.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"input PeopleSortInput\\n{\\n    dob: SortDirectionEnum\\n    lastName: SortDirectionEnum\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#default-sort","title":"Default sort"},{"url":"#choosing-the-sort-fields","title":"Choosing the sort fields"}]},"parent":{"relativePath":"field-extensions/03-sorting.md"},"frontmatter":{"metaTitle":"Add sorting to your collection fields - EntityGraphQL","metaDescription":"Add sorting to your collection fields"}},"allMdx":{"edges":[{"node":{"fields":{"slug":"/authorization","title":"Authorization"}}},{"node":{"fields":{"slug":"/field-extensions","title":"Field Extensions"}}},{"node":{"fields":{"slug":"/entity-framework","title":"Entity Framework"}}},{"node":{"fields":{"slug":"/getting-started","title":"Getting Started"}}},{"node":{"fields":{"slug":"/integration","title":"Tool Integration"}}},{"node":{"fields":{"slug":"/schema-creation","title":"Schema Creation"}}},{"node":{"fields":{"slug":"/","title":"Entity GraphQL"}}},{"node":{"fields":{"slug":"/serialization-naming","title":"Serialization & Field Naming"}}},{"node":{"fields":{"slug":"/validation","title":"Validation"}}},{"node":{"fields":{"slug":"/introduction","title":"Introduction"}}},{"node":{"fields":{"slug":"/schema-creation/02-fields","title":"Field Arguments"}}},{"node":{"fields":{"slug":"/schema-creation/03-types","title":"Other Types"}}},{"node":{"fields":{"slug":"/schema-creation/01-mutations","title":"Mutations"}}},{"node":{"fields":{"slug":"/schema-creation/04-directives","title":"Directives"}}},{"node":{"fields":{"slug":"/field-extensions/01-paging","title":"Paging"}}},{"node":{"fields":{"slug":"/schema-creation/05-other-data-sources","title":"Other Data Sources"}}},{"node":{"fields":{"slug":"/field-extensions/02-filtering","title":"Filtering"}}},{"node":{"fields":{"slug":"/field-extensions/04-custom-extensions","title":"Custom Extensions"}}},{"node":{"fields":{"slug":"/field-extensions/03-sorting","title":"Sorting"}}},{"node":{"fields":{"slug":"/serialization-naming/newtonsoft-json","title":"Using Newtonsoft.Json"}}}]}},"pageContext":{"id":"56ba909b-2e10-5ccc-a0dd-497566eea214"}},
    "staticQueryHashes": ["2619113677","3706406642","417421954"]}