"use strict";(self.webpackChunkentity_graphql_docs=self.webpackChunkentity_graphql_docs||[]).push([[292],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function p(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),i=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):p(p({},t),e)),n},u=function(e){var t=i(e.components);return a.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,l=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),d=i(n),m=r,h=d["".concat(l,".").concat(m)]||d[m]||c[m]||s;return n?a.createElement(h,p(p({ref:t},u),{},{components:n})):a.createElement(h,p({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,p=new Array(s);p[0]=d;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:r,p[1]=o;for(var i=2;i<s;i++)p[i]=n[i];return a.createElement.apply(null,p)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},4655:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>p,default:()=>c,frontMatter:()=>s,metadata:()=>o,toc:()=>i});var a=n(7462),r=(n(7294),n(3905));const s={sidebar_position:6},p="Input Types",o={unversionedId:"schema-creation/input-types",id:"schema-creation/input-types",title:"Input Types",description:"We've seen passing scalar values, like enums, numbers or strings, as arguments into a field. Input types allow us to define complex types that can be used as an argument. This is particularly valuable in the case of mutations, where you might want to pass in a whole object to be created.",source:"@site/docs/schema-creation/input-types.md",sourceDirName:"schema-creation",slug:"/schema-creation/input-types",permalink:"/docs/schema-creation/input-types",draft:!1,editUrl:"https://github.com/EntityGraphQL/EntityGraphQL/tree/master/docs/docs/schema-creation/input-types.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"Interfaces Types & Implements Keyword",permalink:"/docs/schema-creation/interface-types"},next:{title:"Lists and Non-Null",permalink:"/docs/schema-creation/lists-and-nonnulls"}},l={},i=[{value:"One Of Input Types",id:"one-of-input-types",level:2}],u={toc:i};function c(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"input-types"},"Input Types"),(0,r.kt)("p",null,"We've seen passing scalar values, like enums, numbers or strings, as arguments into a field. ",(0,r.kt)("a",{parentName:"p",href:"https://graphql.org/learn/schema/#input-types"},"Input types")," allow us to define complex types that can be used as an argument. This is particularly valuable in the case of mutations, where you might want to pass in a whole object to be created."),(0,r.kt)("p",null,"Input types differ to regular Object types largely because they can't have arguments on their fields. There are just a data object. As described in the spec:"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"The fields on an input object type can themselves refer to input object types, but you can't mix input and output types in your schema. Input object types also can't have arguments on their fields.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cs"},'public class PeopleMutations\n{\n    [GraphQLMutation("Add a new person to the system")]\n    public Expression<Func<DemoContext, Person>> AddNewPerson(DemoContext db, AddPersonArgs args)\n    {\n        var person = new Person\n        {\n            FirstName = args.PersonInput.FirstName,\n            LastName = args.PersonInput.LastName,\n        };\n        db.People.Add(person);\n        db.SaveChanges();\n\n        return (ctx) => ctx.People.First(p => p.Id == person.Id);\n    }\n}\n\n[MutationArguments]\npublic class AddPersonArgs\n{\n    public PersonInput PersonInput { get; set; }\n}\n\npublic class PersonInput\n{\n    public string FirstName { get; set; }\n    public string LastName { get; set; }\n}\n\n\n// creating our schema\nschema.AddInputType<PersonInput>("PersonInput", "New person data")\n    .AddAllFields();\n')),(0,r.kt)("p",null,"You could of course use the ",(0,r.kt)("inlineCode",{parentName:"p"},"Person")," class from your data model directly and be selective about the fields you add to the GraphQL schema."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cs"},'public class PeopleMutations\n{\n    [GraphQLMutation("Add a new person to the system")]\n    public Expression<Func<DemoContext, Person>> AddNewPerson(DemoContext db, AddPersonArgs args)\n    {\n        db.People.Add(args.PersonInput);\n        db.SaveChanges();\n        return (ctx) => ctx.People.First(p => p.Id == person.Id);\n    }\n}\n\n[MutationArguments]\npublic class AddPersonArgs\n{\n    public Person PersonInput { get; set; }\n}\n\n// creating our schema\nvar type = schema.AddInputType<Person>("PersonInput", "New person data")\ntype.AddField("firstName", p => p.FirstName, "First name);\ntype.AddField("lastName", p => p.LastName, "Last name);\n')),(0,r.kt)("p",null,"You can also use complex types in field arguments."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cs"},'public class FilterInput\n{\n    public string FirstName { get; set; }\n    public string LastName { get; set; }\n}\n\nschema.Query().AddField(\n    "people",\n    new {\n        filter = (FilterInput)null\n    },\n    (ctx, args) => ctx.People\n        .WhereWhen(p => p.FistName == args.filter.firstName, !string.IsNullOrEmpty(args.filter.firstName))\n        .WhereWhen(p => p.LastName == args.filter.lastName, !string.IsNullOrEmpty(args.filter.lastName)),\n    "List of people optionally filtered by a first and/or last name"\n);\n\nschema.AddInputType<FilterInput>("FilterInput", "Filter data for people")\n    .AddAllFields();\n')),(0,r.kt)("p",null,"The larger impact of these choices can be seen in the resulting schema and use of the API."),(0,r.kt)("p",null,"With scalar arguments."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'POST localhost:5000/graphql\n    {\n    "query": "mutation AddPerson($firstName: String!, $lastName: String!) {\n        addNewPerson(firstName: $firstName, lastName: $lastName) { id }\n    }",\n    "variables": {\n        "firstName": "Bill",\n        "lastName": "Murray"\n    }\n}\n')),(0,r.kt)("p",null,"With an input type argument"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'POST localhost:5000/graphql\n{\n    "query": "mutation AddPerson($person: PersonInput!) {\n        addNewPerson(personInput: $person) { id }\n    }",\n    "variables": {\n        "personInput": {\n            "firstName": "Bill",\n            "lastName": "Murray"\n        }\n    }\n}\n')),(0,r.kt)("h2",{id:"one-of-input-types"},"One Of Input Types"),(0,r.kt)("p",null,"EntityGraphQL supports ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/graphql/graphql-spec/pull/825"},"One Of Input Types"),"."),(0,r.kt)("p",null,"Mark an input type with ",(0,r.kt)("inlineCode",{parentName:"p"},"GraphQLOneOfAttribute")," and EntityGraphQL will mark the type with ",(0,r.kt)("inlineCode",{parentName:"p"},"@oneOf")," in the schema and validate the input meets the requiements on execution."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cs"},"[GraphQLOneOf]\nprivate class OneOfInputType\n{\n    public int? One { get; set; }\n    public int? Two { get; set; }\n}\n")),(0,r.kt)("p",null,"This will generate the follow grpahql schema."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"input MutationArgs @oneOf {\n  one: Int\n  two: Int\n}\n")),(0,r.kt)("p",null,"Although each field on the input is nullable the ",(0,r.kt)("inlineCode",{parentName:"p"},"@oneOf")," input type has one further validation step."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Exactly one key must be specified")))}c.isMDXComponent=!0}}]);