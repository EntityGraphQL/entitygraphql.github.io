"use strict";(self.webpackChunkentity_graphql_docs=self.webpackChunkentity_graphql_docs||[]).push([[2092],{7627:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>a,metadata:()=>o,toc:()=>h});var n=t(4848),i=t(8453);const a={sidebar_position:11},r="Subscriptions",o={id:"schema-creation/subscriptions",title:"Subscriptions",description:"GraphQL subscriptions outline an agreed way for services to define events & clients to subscribe to events with the familiar GraphQL queries.",source:"@site/docs/schema-creation/subscriptions.md",sourceDirName:"schema-creation",slug:"/schema-creation/subscriptions",permalink:"/docs/schema-creation/subscriptions",draft:!1,unlisted:!1,editUrl:"https://github.com/EntityGraphQL/EntityGraphQL/tree/master/docs/docs/schema-creation/subscriptions.md",tags:[],version:"current",sidebarPosition:11,frontMatter:{sidebar_position:11},sidebar:"tutorialSidebar",previous:{title:"Adding Other Data Sources or Services",permalink:"/docs/schema-creation/other-data-sources"},next:{title:"Operation Directives",permalink:"/docs/directives/operation-directives"}},c={},h=[{value:"Chat Example",id:"chat-example",level:2},{value:"What is Happening",id:"what-is-happening",level:2},{value:"Load Balances and Lambdas/Functions",id:"load-balances-and-lambdasfunctions",level:2},{value:"Query or Mutation over Web Sockets",id:"query-or-mutation-over-web-sockets",level:2},{value:"Other Implementations",id:"other-implementations",level:2}];function l(e){const s={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(s.header,{children:(0,n.jsx)(s.h1,{id:"subscriptions",children:"Subscriptions"})}),"\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.a,{href:"https://spec.graphql.org/October2021/#sec-Subscription",children:"GraphQL subscriptions"})," outline an agreed way for services to define events & clients to subscribe to events with the familiar GraphQL queries."]}),"\n",(0,n.jsx)(s.admonition,{type:"info",children:(0,n.jsxs)(s.p,{children:["The GraphQL spec does not define how a server should implement this functionality. EntityGraphQL implements the ",(0,n.jsx)(s.a,{href:"https://github.com/enisdenjo/graphql-ws/blob/master/PROTOCOL.md",children:"graphql-ws"})," protocol. This uses web sockets to deliver messages between the client & server. This is well supported by libraries like ",(0,n.jsx)(s.a,{href:"https://www.apollographql.com/docs/react/data/subscriptions/",children:"Apollo"}),"."]})}),"\n",(0,n.jsxs)(s.p,{children:["In EntityGraphQL subscriptions are defined similarly to how mutations are except the return value should be an ",(0,n.jsx)(s.code,{children:"IObservable<T>"}),". When EntityGraphQL receives a subscription operation from a client, it will"]}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:"execute the registered subscription method"}),"\n",(0,n.jsxs)(s.li,{children:["subscribe to that result of that method (the ",(0,n.jsx)(s.code,{children:"IObservable<T>"}),")"]}),"\n",(0,n.jsxs)(s.li,{children:["on receiving new data from the ",(0,n.jsx)(s.code,{children:"IObservable<T>"})," EntityGraphQL will execute the field selection over the data and publish new data to client"]}),"\n"]}),"\n",(0,n.jsx)(s.h2,{id:"chat-example",children:"Chat Example"}),"\n",(0,n.jsxs)(s.p,{children:["Let's look at a simple chat event. You can see the full code in the ",(0,n.jsx)(s.a,{href:"https://github.com/EntityGraphQL/EntityGraphQL/tree/master/src/examples/subscriptions",children:"subscription example"})," on GitHub."]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-cs",children:'public class ChatSubscriptions\n{\n    [GraphQLSubscription("Subscription to new messages")]\n    public IObservable<Message> OnMessage(ChatService chat)\n    {\n        return chat.Subscribe();\n    }\n}\n'})}),"\n",(0,n.jsxs)(s.p,{children:["Here is a simple ",(0,n.jsx)(s.code,{children:"ChatService"})," that uses that the EntityGraphQL supplied ",(0,n.jsx)(s.code,{children:"Broadcaster<T>"})," class to broadcast new events to any subscribers. The ",(0,n.jsx)(s.code,{children:"Broadcast<T>.Subscribe()"})," returns an object that implements ",(0,n.jsx)(s.code,{children:"IObservable<T>"})," which is what the subscription registration method above returns. You could also implement your own ",(0,n.jsx)(s.code,{children:"IObservable<T>"}),", internally EntityGraphQL calls ",(0,n.jsx)(s.code,{children:"Subscribe()"})," on the result."]}),"\n",(0,n.jsx)(s.p,{children:"Here is our simple chat service that handles receiving new messages and broadcasting them."}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-cs",children:"public class ChatService\n{\n    // highlight-next-line\n    private readonly Broadcaster<Message> broadcaster = new();\n\n    public Message PostMessage(ChatContext db, string message, string user)\n    {\n        var msg = new Message\n        {\n            Id = Guid.NewGuid(),\n            Text = message,\n            Timestamp = DateTime.Now,\n            UserId = user,\n        };\n\n        db.Messages.Add(msg);\n        db.SaveChanges();\n\n        broadcaster.OnNext(msg);\n\n        return msg;\n    }\n    // highlight-start\n    public IObservable<Message> Subscribe()\n    {\n        return broadcaster;\n    }\n    // highlight-end\n}\n"})}),"\n",(0,n.jsx)(s.p,{children:"Setting up our application - register our schema, enable web sockets and GraphQLWebSockets"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-cs",children:"// ...\nbuilder.Services.AddSingleton<ChatService>();\nbuilder.Services.AddGraphQLSchema<ChatContext>(options =>\n{\n    options.ConfigureSchema = (schema) => {\n        schema.Mutation().AddFrom<ChatMutations>();\n        // highlight-next-line\n        schema.Subscription().AddFrom<ChatSubscriptions>();\n    }\n});\n\nvar app = builder.Build();\n// ...\n\n// highlight-next-line\napp.UseWebSockets();\n\napp.UseRouting();\n\n// highlight-next-line\napp.UseGraphQLWebSockets<ChatContext>();\n\napp.UseEndpoints(endpoints =>\n{\n    endpoints.MapGraphQL<ChatContext>();\n});\n\napp.Run();\n"})}),"\n",(0,n.jsxs)(s.admonition,{type:"info",children:[(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.code,{children:"UseGraphQLWebSockets"})," registers a new URL endpoint at ",(0,n.jsx)(s.code,{children:"/subscriptions"})," by default. This differs to the query/mutation endpoint default of ",(0,n.jsx)(s.code,{children:"/graphql"}),". You can change either with the ",(0,n.jsx)(s.code,{children:"path"})," parameter in ",(0,n.jsx)(s.code,{children:"UseGraphQLWebSockets"})," or ",(0,n.jsx)(s.code,{children:"MapGraphQL"}),"."]}),(0,n.jsxs)(s.p,{children:["If you are using a tool like Postman, it expects the paths to be the same so you will need to tell it the correct path or use ",(0,n.jsx)(s.code,{children:'UseGraphQLWebSockets<ChatContext>(path: "/graphql")'}),"."]})]}),"\n",(0,n.jsxs)(s.p,{children:["We will use a mutation to allow clients to post messages as well, it uses the ",(0,n.jsx)(s.code,{children:"ChatService"})," to post new messages, which as you see above broadcasts new messages to subscribers."]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-cs",children:"public class ChatMutations\n{\n    [GraphQLMutation]\n    public static Expression<Func<ChatContext, Message>> PostMessage(ChatContext db, string message, string user, ChatService chat)\n    {\n        var postedMessage = chat.PostMessage(db, message, user);\n        return ctx => ctx.Messages.First(message => message.Id == postedMessage.Id);\n    }\n}\n"})}),"\n",(0,n.jsxs)(s.p,{children:["Now when a client uses the ",(0,n.jsx)(s.code,{children:"postMessage"})," mutation (which triggers ",(0,n.jsx)(s.code,{children:"ChatService.PostMessage()"}),"), or anything else in the server that triggers ",(0,n.jsx)(s.code,{children:"ChatService.PostMessage()"}),", subscribers will receive the new data (only the fields they requested)."]}),"\n",(0,n.jsx)(s.h2,{id:"what-is-happening",children:"What is Happening"}),"\n",(0,n.jsxs)(s.p,{children:["Following the ",(0,n.jsxs)(s.a,{href:"https://github.com/enisdenjo/graphql-ws/blob/master/PROTOCOL.md",children:[(0,n.jsx)(s.code,{children:"graphql-ws"})," protocol"]}),", once a client has sent the ",(0,n.jsx)(s.code,{children:"connection_init"})," message and received the ",(0,n.jsx)(s.code,{children:"connection_ack"})," message back it can send a ",(0,n.jsx)(s.code,{children:"subscribe"})," message with a unique ID and the payload is the GraphQL subscription operation:"]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-graphql",children:"subscription ChatRoom {\n  onMessage {\n    id\n    user\n    text\n    timestamp\n  }\n}\n"})}),"\n",(0,n.jsx)(s.admonition,{type:"info",children:(0,n.jsxs)(s.p,{children:["The ",(0,n.jsx)(s.code,{children:"graphql-ws"})," protocol uses messages to communicate over the web socket connection it has with the server. Multiple subscriptions may be maintained over that connection this way using a unique ID for each subscription."]})}),"\n",(0,n.jsxs)(s.p,{children:["When EntityGraphQL executes the above graphql it receives the ",(0,n.jsx)(s.code,{children:"IObservable<T>"})," as the result. No data is sent to the client at this stage. The ",(0,n.jsx)(s.code,{children:"IObservable<T>"})," result is held with other metadata (like the schema, connection) in a ",(0,n.jsx)(s.code,{children:"WebSocketSubscription<TQueryContext>"})," object that represents a single subscription on a web socket connection. That connection may have multiple subscriptions."]}),"\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.code,{children:"WebSocketSubscription<TQueryContext>"})," subscribes to the ",(0,n.jsx)(s.code,{children:"IObservable<T>"})," and on new data it executes the GraphQL field selection over that data and sends the result to the client over the web socket connection as the payload of a ",(0,n.jsx)(s.code,{children:"next"})," message containing the ID for the subscription."]}),"\n",(0,n.jsx)(s.h2,{id:"load-balances-and-lambdasfunctions",children:"Load Balances and Lambdas/Functions"}),"\n",(0,n.jsxs)(s.p,{children:["In the above chat example we have a way to post new messages and have those new messages published to all clients subscribed. You may be wondering about events triggered on different servers or from other services. For example if you use load balancers to scale, a ",(0,n.jsx)(s.code,{children:"postMessage"})," may be delivered to server ",(0,n.jsx)(s.code,{children:"A"})," while some clients have a web socket connection to server ",(0,n.jsx)(s.code,{children:"B"}),". You will need a way to have server ",(0,n.jsx)(s.code,{children:"A"})," tell server ",(0,n.jsx)(s.code,{children:"B"})," that there is new data so it can notify the subscribers."]}),"\n",(0,n.jsx)(s.p,{children:"This is why the GraphQL specification does not dictate implementation details!"}),"\n",(0,n.jsx)(s.p,{children:"A typical implementation of this pattern is using a stream or queue service where your servers or services post events to that and listen for events too. EntityGraphQL does not aim to implement a fully distributed queue system (there ae many great choices). It aims to provide the glue to support the GraphQL subscription specification."}),"\n",(0,n.jsxs)(s.p,{children:["If you are hosting a ASP.NET application behind a load balancer you could have ",(0,n.jsx)(s.code,{children:"ChatService"})," post message events to a stream/queue, have your application (on each server it is running) subscribe to events from the stream/queue which can then broadcast that event to any subscribers connected."]}),"\n",(0,n.jsx)(s.p,{children:"If you are using lambdas/functions you will have to do a similar thing with a stream or queue with the added complexity of handling web sockets through an API Gateway or similar."}),"\n",(0,n.jsx)(s.admonition,{type:"tip",children:(0,n.jsx)(s.p,{children:"Got ideas that would help users implement these patterns? Please reach out or open a PR with examples!"})}),"\n",(0,n.jsx)(s.h2,{id:"query-or-mutation-over-web-sockets",children:"Query or Mutation over Web Sockets"}),"\n",(0,n.jsxs)(s.p,{children:["The ",(0,n.jsx)(s.a,{href:"https://github.com/enisdenjo/graphql-ws/blob/master/PROTOCOL.md#single-result-operation",children:(0,n.jsx)(s.code,{children:"graphql-ws"})})," protocol also supports executing GraphQL ",(0,n.jsx)(s.code,{children:"query"})," and ",(0,n.jsx)(s.code,{children:"mutation"})," operations over the connection. This is supported by EntityGraphQL and follows the specification. However typically clients will use HTTPS for ",(0,n.jsx)(s.code,{children:"query"})," and ",(0,n.jsx)(s.code,{children:"mutation"})," operations and web sockets for ",(0,n.jsx)(s.code,{children:"subscription"})," operations to aid with scale."]}),"\n",(0,n.jsx)(s.h2,{id:"other-implementations",children:"Other Implementations"}),"\n",(0,n.jsxs)(s.p,{children:["The above GraphQL subscription implementation is based on ",(0,n.jsx)(s.a,{href:"https://github.com/enisdenjo/graphql-ws/blob/master/PROTOCOL.md",children:(0,n.jsx)(s.code,{children:"graphql-ws"})})," protocol which uses web sockets. It is provided by the ",(0,n.jsx)(s.a,{href:"https://www.nuget.org/packages/EntityGraphQL.AspNet",children:"EntityGraphQL.AspNet"})," package. The base ",(0,n.jsx)(s.a,{href:"https://www.nuget.org/packages/EntityGraphQL",children:"EntityGraphQL"})," package does not know about web sockets, there is potential to implement other transport layers or protocols on top of that."]}),"\n",(0,n.jsxs)(s.p,{children:["The result you will get from executing a subscription statement as above is the ",(0,n.jsx)(s.code,{children:"GraphQLSubscribeResult"})," object that looks like this:"]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-cs",children:"public class GraphQLSubscribeResult\n{\n    // The T in IObservable<T> - the data we are returning\n    Type EventType { get; }\n    // Used to call .ExecuteSubscriptionEvent() when you have new data\n    GraphQLSubscriptionStatement SubscriptionStatement { get; }\n    // Passed to the ExecuteSubscriptionEvent() call\n    GraphQLSubscriptionField Field { get; }\n    // Returns the IObservable<T> object. This is an object because at compile time we can't just cast the IObservable<T> as T is not known to us. See GraphQLSubscriptionStatement.ExecuteAsync() to see where this is created\n    object GetObservable();\n}\n"})}),"\n",(0,n.jsxs)(s.p,{children:["You will be able to subscribe to the ",(0,n.jsx)(s.code,{children:"IObservable<T>"})," and execute the selection when you have new data available with ",(0,n.jsx)(s.code,{children:"SubscriptionStatement"})," and ",(0,n.jsx)(s.code,{children:"Field"}),"."]})]})}function d(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},8453:(e,s,t)=>{t.d(s,{R:()=>r,x:()=>o});var n=t(6540);const i={},a=n.createContext(i);function r(e){const s=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),n.createElement(a.Provider,{value:s},e.children)}}}]);