"use strict";(self.webpackChunkentity_graphql_docs=self.webpackChunkentity_graphql_docs||[]).push([[5326],{1839:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>l,toc:()=>c});var i=t(4848),o=t(8453);const s={sidebar_position:3},a="Paging",l={id:"field-extensions/paging",title:"Paging",description:"Paging can be handled in any way you can build your field expressions. It all depends on your requirements and how you want your API to work.",source:"@site/docs/field-extensions/paging.md",sourceDirName:"field-extensions",slug:"/field-extensions/paging",permalink:"/docs/field-extensions/paging",draft:!1,unlisted:!1,editUrl:"https://github.com/EntityGraphQL/EntityGraphQL/tree/master/docs/docs/field-extensions/paging.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Sorting",permalink:"/docs/field-extensions/sorting"},next:{title:"Custom Extensions",permalink:"/docs/field-extensions/custom-extensions"}},r={},c=[{value:"Connection Paging Model",id:"connection-paging-model",level:2},{value:"Default &amp; Max Page Size",id:"default--max-page-size",level:3},{value:"Connection Model Implementation",id:"connection-model-implementation",level:3},{value:"Offset Paging",id:"offset-paging",level:2},{value:"Default &amp; Max Page Size",id:"default--max-page-size-1",level:3},{value:"Custom Paging",id:"custom-paging",level:3}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"paging",children:"Paging"})}),"\n",(0,i.jsx)(n.p,{children:"Paging can be handled in any way you can build your field expressions. It all depends on your requirements and how you want your API to work."}),"\n",(0,i.jsx)(n.p,{children:"The API user will just have to keep asking for more items until it doesn't get any results."}),"\n",(0,i.jsx)(n.p,{children:"Note: When using one of the below field extensions with any of the other field extensions, make sure the paging one is added last. Filter -> Sort -> Paging."}),"\n",(0,i.jsx)(n.h2,{id:"connection-paging-model",children:"Connection Paging Model"}),"\n",(0,i.jsxs)(n.p,{children:["Quickly you'll see the above lacks useful metadata - are there more items? What is the total items? etc. GraphQL doesn't have requirements on a particular way to do this, although the community (e.g. ",(0,i.jsx)(n.a,{href:"https://relay.dev/graphql/connections.htm",children:"Relay"}),") have landed on the ",(0,i.jsx)(n.a,{href:"https://graphql.org/learn/pagination/",children:"Connection Model"}),". EntityGraphQL contains an easy field extension method to implement this in your schema - ",(0,i.jsx)(n.code,{children:"UseConnectionPaging()"}),". This can only be applied to fields that return a collection type."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cs",children:'schemaProvider.ReplaceField("movies",\n  db => db.Movies.OrderBy(e => e.Id) // best to give the field an order so pages are the same\n  "Get a page of movies"\n)\n.UseConnectionPaging();\n'})}),"\n",(0,i.jsxs)(n.p,{children:["If you are using the ",(0,i.jsx)(n.code,{children:"SchemaBuilder.FromObject"})," you can use the ",(0,i.jsx)(n.code,{children:"UseConnectionPagingAttribute"})," on your collection properties. It takes the same arguments as ",(0,i.jsx)(n.code,{children:"UseConnectionPaging()"})," outlined below."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cs",children:"public class DemoContext : DbContext\n{\n    [UseConnectionPaging]\n    public DbSet<Movie> Movies { get; set; }\n    [UseConnectionPaging]\n    public DbSet<Person> People { get; set; }\n    [UseConnectionPaging]\n    public DbSet<Actor> Actors { get; set; }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This will make the field return a schema type of ",(0,i.jsx)(n.code,{children:"MovieConnection"}),", which is built from the .NET type below where ",(0,i.jsx)(n.code,{children:"TEntity"})," would be ",(0,i.jsx)(n.code,{children:"Movie"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cs",children:'public class Connection<TEntity>\n{\n  [GraphQLNotNull]\n  [Description("Edge information about each node in the collection")]\n  public IEnumerable<ConnectionEdge<TEntity>> Edges { get; set; }\n\n  [GraphQLNotNull]\n  [Description("Total count of items in the collection")]\n  public int TotalCount { get; set; }\n\n  [GraphQLNotNull]\n  [Description("Information about this page of data")]\n  public ConnectionPageInfo PageInfo { get; set; }\n}\n\npublic class ConnectionEdge<TEntity>\n{\n  [GraphQLNotNull]\n  [Description("The item of the collection")]\n  public TEntity Node { get; set; }\n\n  [GraphQLNotNull]\n  [Description("The cursor for this items position within the collection")]\n  public string Cursor { get; set; }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["This follows the Relay Connection Model pattern and lets you page through data easily with code using the cursor metadata. As in the example above you should give your collection an order otherwise depending on the underlying data source the order could change over pages/queries. You can order base on other arguments you have on the field, ",(0,i.jsx)(n.code,{children:"UseConnectionPaging()"})," will merge the arguments together."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cs",children:'schemaProvider.ReplaceField("movies",\n  new {\n    year = (int?)null,\n    orderByRelease = (bool?)null\n  },\n  (db, args) => db.Movies\n    .WhereWhen(m => m.Released.Year == args.year, args.year.HasValue)\n    .OrderBy(e => args.orderByRelease ? e.Released : e.Id)\n  "Get a page of movies"\n)\n.UseConnectionPaging();\n'})}),"\n",(0,i.jsx)(n.p,{children:"Below shows the available fields on the new connection type (as always you can explore you schema in something like GraphiQL)."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:'movies(first: 4, after: "MQ==") {\n    edges {\n      cursor\n      node { # this is your expected Movie context\n        name\n      }\n    }\n    pageInfo {\n      hasPreviousPage\n      hasNextPage\n      startCursor\n      endCursor\n    }\n    totalCount\n  }\n'})}),"\n",(0,i.jsx)(n.h3,{id:"default--max-page-size",children:"Default & Max Page Size"}),"\n",(0,i.jsx)(n.p,{children:"You can set an optional default page size or max page size for the connection paging model."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cs",children:"myField\n.UseConnectionPaging(\n  defaultPageSize: 10,\n  maxPageSize: 50\n)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["If ",(0,i.jsx)(n.code,{children:"first"})," and ",(0,i.jsx)(n.code,{children:"last"})," arguments are ",(0,i.jsx)(n.code,{children:"null"})," the ",(0,i.jsx)(n.code,{children:"defaultPageSize"})," value will be set to the ",(0,i.jsx)(n.code,{children:"first"})," argument."]}),"\n",(0,i.jsxs)(n.p,{children:["If either ",(0,i.jsx)(n.code,{children:"first"})," or ",(0,i.jsx)(n.code,{children:"last"})," arguments are greater then the ",(0,i.jsx)(n.code,{children:"maxPageSize"})," value an error is raised and the query will fail."]}),"\n",(0,i.jsx)(n.h3,{id:"connection-model-implementation",children:"Connection Model Implementation"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"Cursor"})," in the connection paging model is built on the row index of the item. As suggested in the ",(0,i.jsx)(n.a,{href:"https://graphql.org/learn/pagination/#complete-connection-model",children:"connection model"})," the row index is encoded."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"As a reminder that the cursors are opaque and that their format should not be relied upon, we suggest base64 encoding them."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"offset-paging",children:"Offset Paging"}),"\n",(0,i.jsxs)(n.p,{children:["EntityGraphQL also provides a offset based (",(0,i.jsx)(n.code,{children:"Skip"}),"/",(0,i.jsx)(n.code,{children:"Take"}),") extension method to apply a offset based paging model to your fields."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cs",children:'schemaProvider.ReplaceField("movies",\n  db => db.Movies.OrderBy(e => e.Id) // best to give the field an order so pages are the same\n  "Get a page of movies"\n)\n.UseOffsetPaging();\n'})}),"\n",(0,i.jsxs)(n.p,{children:["If you are using the ",(0,i.jsx)(n.code,{children:"SchemaBuilder.FromObject"})," you can use the ",(0,i.jsx)(n.code,{children:"UseOffsetPagingAttribute"})," on your collection properties. It takes the same arguments as ",(0,i.jsx)(n.code,{children:"UseOffsetPaging()"})," outlined below."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cs",children:"public class DemoContext : DbContext\n{\n    [UseOffsetPaging]\n    public DbSet<Movie> Movies { get; set; }\n    [UseOffsetPaging]\n    public DbSet<Person> People { get; set; }\n    [UseOffsetPaging]\n    public DbSet<Actor> Actors { get; set; }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This will make the field return a schema type of ",(0,i.jsx)(n.code,{children:"MovieOffsetPage"}),", which is built from the .NET type below where ",(0,i.jsx)(n.code,{children:"TEntity"})," would be ",(0,i.jsx)(n.code,{children:"Movie"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cs",children:'public class OffsetPage<TEntity>\n{\n    [Description("Items in the page")]\n    public IEnumerable<TEntity> Items { get; set; }\n\n    [Description("True if there is more data before this page")]\n    public bool HasPreviousPage { get; set; }\n\n    [Description("True if there is more data after this page")]\n    public bool HasNextPage { get; set; }\n\n    [Description("Count of the total items in the collection")]\n    public int TotalItems { get; set; }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"default--max-page-size-1",children:"Default & Max Page Size"}),"\n",(0,i.jsx)(n.p,{children:"You can set an optional default page size or max page size for the offset paging model."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cs",children:"myField\n.UseOffsetPaging(\n  defaultPageSize: 10,\n  maxPageSize: 50\n)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["If the ",(0,i.jsx)(n.code,{children:"take"})," argument is ",(0,i.jsx)(n.code,{children:"null"})," the ",(0,i.jsx)(n.code,{children:"defaultPageSize"})," value will be set to it."]}),"\n",(0,i.jsxs)(n.p,{children:["If the ",(0,i.jsx)(n.code,{children:"take"})," argument is greater then the ",(0,i.jsx)(n.code,{children:"maxPageSize"})," value an error is raised and the query will fail."]}),"\n",(0,i.jsx)(n.h3,{id:"custom-paging",children:"Custom Paging"}),"\n",(0,i.jsxs)(n.p,{children:["A simple example is to use ",(0,i.jsx)(n.code,{children:"skip"})," and ",(0,i.jsx)(n.code,{children:"take"})," arguments in your collection fields. For example in the schema we have been working with we could modify the ",(0,i.jsx)(n.code,{children:"movies"})," field (and other collections) like so."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cs",children:'schemaProvider.ReplaceField(\n  "movies",\n  new { // add our field arguments\n    take = 10, // defaults\n    skip = 0\n  },\n  (db, args) => db.Movies\n    .Skip(args.skip) // do paging\n    .Take(args.take),\n  "Get a page of movies"\n);\n'})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>l});var i=t(6540);const o={},s=i.createContext(o);function a(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);