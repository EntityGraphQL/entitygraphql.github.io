"use strict";(self.webpackChunkentity_graphql_docs=self.webpackChunkentity_graphql_docs||[]).push([[642],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>c});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),m=p(n),c=r,h=m["".concat(l,".").concat(c)]||m[c]||d[c]||o;return n?a.createElement(h,s(s({ref:t},u),{},{components:n})):a.createElement(h,s({ref:t},u))}));function c(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,s=new Array(o);s[0]=m;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var p=2;p<o;p++)s[p]=n[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},8678:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const o={sidebar_position:2},s="Mutations",i={unversionedId:"schema-creation/mutations",id:"schema-creation/mutations",title:"Mutations",description:"GraphQLs mutations allow you to make modifications to your data.",source:"@site/docs/schema-creation/mutations.md",sourceDirName:"schema-creation",slug:"/schema-creation/mutations",permalink:"/docs/schema-creation/mutations",draft:!1,editUrl:"https://github.com/EntityGraphQL/EntityGraphQL/tree/master/docs/docs/schema-creation/mutations.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Fields",permalink:"/docs/schema-creation/fields"},next:{title:"Scalar Types",permalink:"/docs/schema-creation/scalar-types"}},l={},p=[{value:"Adding a mutation controller",id:"adding-a-mutation-controller",level:2},{value:"AddMutationsFrom method arguments",id:"addmutationsfrom-method-arguments",level:2},{value:"Adding a Mutations as a Delegate",id:"adding-a-mutations-as-a-delegate",level:2},{value:"Mutation arguments",id:"mutation-arguments",level:2},{value:"Dependencies Injection &amp; Services",id:"dependencies-injection--services",level:3},{value:"<code>MutationArguments</code> classes",id:"mutationarguments-classes",level:3},{value:"Why Use <code>Expression</code> Return Type",id:"why-use-expression-return-type",level:2}],u={toc:p};function d(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"mutations"},"Mutations"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://graphql.org/learn/queries/#mutations"},"GraphQLs mutations")," allow you to make modifications to your data."),(0,r.kt)("p",null,"In EntityGraphQL mutations are just .NET methods in a class called a mutation controller."),(0,r.kt)("h2",{id:"adding-a-mutation-controller"},"Adding a mutation controller"),(0,r.kt)("p",null,"Define related mutations as methods in a class, and apply the ",(0,r.kt)("inlineCode",{parentName:"p"},"[GraphQLMutation]")," attribute to each method."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cs"},'public class PeopleMutations\n{\n    [GraphQLMutation("Add a new person to the system")]\n    public Expression<Func<DemoContext, Person>> AddNewPerson(DemoContext db, string firstName, string lastName)\n    {\n        var person = new Person\n        {\n            FirstName = firstName,\n            LastName = lastName,\n        };\n        db.People.Add(person);\n        db.SaveChanges();\n\n        return (ctx) => ctx.People.First(p => p.Id == person.Id);\n    }\n}\n')),(0,r.kt)("p",null,"You can add the mutation controller to a schema in the following ways:"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Register a mutation controller")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cs"},"schema.AddMutationsFrom<PeopleMutations>();\n")),(0,r.kt)("p",null,"EntityGraphQL adds the ",(0,r.kt)("inlineCode",{parentName:"p"},"PeopleMutations")," mutation controller and all its mutation methods (those with ",(0,r.kt)("inlineCode",{parentName:"p"},"[GraphQLMutation]")," applied) to the schema."),(0,r.kt)("p",null,"For each mutation request, EntityGraphQL creates a new instance of ",(0,r.kt)("inlineCode",{parentName:"p"},"PeopleMuations"),". The constructor and mutation methods accept services passed through ",(0,r.kt)("a",{parentName:"p",href:"#dependencies-injection--services"},"dependency injection"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Register all mutation controllers implementing or derving from a type")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cs"},"schema.AddMutationsFrom<IPersonnelMutations>();\n")),(0,r.kt)("p",null,"If the type parameter to ",(0,r.kt)("inlineCode",{parentName:"p"},"AddMutationsFrom")," is an interface or base class, EntityGraphQL also adds as mutation controllers all types (in the same assembly) that implement the interface or derive from the base class. In example above, all classes that implement ",(0,r.kt)("inlineCode",{parentName:"p"},"IPersonnelMutations")," would be added to the schema."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Now we can add people!")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},'mutation {\n  addNewPerson(firstName: "Bill", lastName: "Murray") {\n    id\n    fullName\n  }\n}\n')),(0,r.kt)("p",null,"Above we use our mutation to add a person and select their ",(0,r.kt)("inlineCode",{parentName:"p"},"fullName")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"id")," in the result."),(0,r.kt)("h2",{id:"addmutationsfrom-method-arguments"},"AddMutationsFrom method arguments"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cs"},"  void AddMutationsFrom<TType>(SchemaBuilderMethodOptions? options =  null) where TType : class;\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"SchemaBuilderMethodOptions.AutoCreateInputTypes"),"\nIf true (default = false) and an object type is encountered during reflection of the mutation parameters it will be added to the schema as an InputObject type."),(0,r.kt)("p",null,"If you set this to true, EntityGraphQL doesn't know which objects should be InputTypes or are services to be injected at execution as the ",(0,r.kt)("inlineCode",{parentName:"p"},"ServiceProvider")," is not supplied at schema screation."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"SchemaBuilderMethodOptions.AddNonAttributedMethods"),"\nIf true (deafult = false), EntityGraphQL will add any method in the mutation class as a mutation without needing the ",(0,r.kt)("inlineCode",{parentName:"p"},"[GraphQLMutation]")," attribute. Methods must be ",(0,r.kt)("strong",{parentName:"p"},"Public")," and ",(0,r.kt)("strong",{parentName:"p"},"not inherited")," but can be either ",(0,r.kt)("strong",{parentName:"p"},"static")," or ",(0,r.kt)("strong",{parentName:"p"},"instance"),"."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"SchemaBuilderMethodOptions")," in herits from ",(0,r.kt)("inlineCode",{parentName:"p"},"SchemaBuilderOptions")," and those options are passed to the ",(0,r.kt)("inlineCode",{parentName:"p"},"SchemaBuilder")," methods. An important one for mutations is"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"SchemaBuilderOptions.AutoCreateNewComplexTypes"),"\nIf true (default = true) any complex class types that a mutation returns is added to the schema as a query type if it is not already there."),(0,r.kt)("h2",{id:"adding-a-mutations-as-a-delegate"},"Adding a Mutations as a Delegate"),(0,r.kt)("p",null,"You can also add individual mutation methods to the mutation type as delegates or inline methods."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cs"},'class PeopleMutations\n{\n    public class void Configure(ISchemaProvider<DemoContext> schema)\n    {\n        schema.Mutation().Add("peopleMutations", "Add a new person to the system", AddNewPerson);\n\n        schema.Mutation().Add("peopleMutations", "Do somethign else", (OtherArgs args) => {\n            // ... mutate logic here\n        });\n    }\n\n    public Expression<Func<DemoContext, Person>> AddNewPerson(DemoContext db, string firstName, string lastName)\n    {\n        var person = new Person\n        {\n            FirstName = firstName,\n            LastName = lastName,\n        };\n        db.People.Add(person);\n        db.SaveChanges();\n\n        return (ctx) => ctx.People.First(p => p.Id == person.Id);\n    }\n}\n')),(0,r.kt)("h2",{id:"mutation-arguments"},"Mutation arguments"),(0,r.kt)("p",null,"Above we have 3 arguments in our mutation. The ",(0,r.kt)("inlineCode",{parentName:"p"},"DemoContext")," is injected using the context instance we were passed to execute the query."),(0,r.kt)("p",null,"The other 2 parameters EntityGraphQL does not know where they come from so will consider them arguments in the mutation field that are to be supplied."),(0,r.kt)("p",null,"For example the above mutation generates the follow in the GraphQL schema."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"type Mutation {\n  addNewPerson(firstName: String, lastName: String): Person!\n}\n")),(0,r.kt)("p",null,"Any mutation argument that EntityGraphQL can not resolve will be added to the schema as an argument on that mutation."),(0,r.kt)("h3",{id:"dependencies-injection--services"},"Dependencies Injection & Services"),(0,r.kt)("p",null,"You likely want to access some services in your mutations. EntityGraphQL supports dependency injection. When you execute a query make sure you pass in an ",(0,r.kt)("inlineCode",{parentName:"p"},"IServiceProvider"),". Here is an example with ASP.NET."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Note: If you use ",(0,r.kt)("a",{parentName:"em",href:"https://www.nuget.org/packages/EntityGraphQL.AspNet"},"EntityGraphQL.AspNet")," the registered ",(0,r.kt)("inlineCode",{parentName:"em"},"IServiceProvider")," is provided.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cs"},"var results = _schemaProvider.ExecuteRequest(query, demoContext, HttpContext.RequestServices, null);\n")),(0,r.kt)("p",null,"EntityGraphQL will use that ",(0,r.kt)("inlineCode",{parentName:"p"},"IServiceProvider")," to resolve any services when calling your mutation method. All you need to do is make sure the service is registered and include it as a parameter of the mutation controller constructor or a mutation method."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cs"},'// in Startup.cs\nservices.AddSingleton<IDemoService, DemoService>();\n\n// your mutation method\n[GraphQLMutation("Add a new person to the system.")]\npublic Expression<Func<DemoContext, Person>> AddNewPerson(DemoContext db, AddPersonArgs args, IDemoService demoService)\n{\n    // do something cool with demoService\n\n    return (db) => db.People.First(p => p.Id == person.Id);\n}\n')),(0,r.kt)("p",null,"Dependencies can also be defined at the class level, which is convenient when used by multiple mutations or in a helper method:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cs"},"class PeopleMutations(IDemoService demoService)\n{\n    private readonly IDemoService demoService;\n\n    public PeopleMutations(IDemoService demoService)\n    {\n        this.demoService = demoService;\n    }\n\n    public Expression<Func<DemoContext, Person>> AddNewPerson(DemoContext db, string firstName, string lastName)\n    {\n        // Use ServiceHelper\n    }\n\n    public Expression<Func<DemoContext, Person>> SetPersonJob(DemoContext db, string job)\n    {\n        // Use ServiceHelper\n    }\n\n    void ServiceHelper(Person person)\n    {\n        // Use demoService\n    }\n}\n")),(0,r.kt)("p",null,"Later we'll learn how to access services within query fields of the schema."),(0,r.kt)("h3",{id:"mutationarguments-classes"},(0,r.kt)("inlineCode",{parentName:"h3"},"MutationArguments")," classes"),(0,r.kt)("p",null,"Depending on the complexity of your mutation you may end up with many method arguments to build the mutation field schema arguments. Consider a mutation that creates an object and lets you pass all the properties in."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cs"},'[GraphQLMutation("Add a new person to the system.")]\npublic Expression<Func<DemoContext, Person>> AddNewPerson(DemoContext db,\n    string firstName,\n    string lastName,\n    string middleName,\n    DateTime dob,\n    int parent1Id,\n    int parent2Id,\n    string[] favFood,\n    // ... it could go on)\n{\n    // ...\n}\n')),(0,r.kt)("p",null,"You may also have mutations where you want to have the same or similar arguments. EntityGraphQL lets you use a MutationArguments class. If a parameter in the method has the ",(0,r.kt)("inlineCode",{parentName:"p"},"MutationArgumentsAttribute")," that type will be expanded. The above could be changed to the following."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cs"},'[GraphQLMutation("Add a new person to the system.")]\npublic Expression<Func<DemoContext, Person>> AddNewPerson(DemoContext db, AddPersonArgs args)\n{\n    // use args.*\n}\n\n[MutationArguments]\npublic class AddPersonArgs\n{\n    public String FirstName { get; set; }\n    public String LastName { get; set; }\n    public String MiddleName { get; set; }\n    public DateTime Dob { get; set; }\n    public int Parent1Id { get; set; }\n    public int Parent2Id { get; set; }\n    public String[] FavFood { get; set; }\n    // ... it could go on\n}\n')),(0,r.kt)("p",null,"MutationArgument classes provide some flexibility in using inheritence etc for common mutation fields. Both still generate the same mutation field in the GraphQL schema."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"type Mutation {\n  addNewPerson(\n    firstName: String\n    lastName: String\n    middleName: String\n    dob: String\n    parent1Id: Int\n    parent2Id: Int\n    favFood: [String]\n  ): Person!\n}\n")),(0,r.kt)("h2",{id:"why-use-expression-return-type"},"Why Use ",(0,r.kt)("inlineCode",{parentName:"h2"},"Expression")," Return Type"),(0,r.kt)("p",null,"Note the return signature above and the result we return is an ",(0,r.kt)("inlineCode",{parentName:"p"},"Expression<Func<>>")," that selects the person we just modified."),(0,r.kt)("p",null,"Just like in queries, if the mutation field returns an object type, you can ask for nested fields. This can be useful for fetching the new state of an object after an update."),(0,r.kt)("p",null,"One API user may ask for the ",(0,r.kt)("inlineCode",{parentName:"p"},"id")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},'mutation {\n  addNewPerson(firstName: "Bill", lastName: "Murray") {\n    id\n  }\n}\n')),(0,r.kt)("p",null,"And another might want more"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},'mutation {\n  addNewPerson(firstName: "Bill", lastName: "Murray") {\n    id\n    firstName\n    fullName\n  }\n}\n')),(0,r.kt)("p",null,"As you don't know which fields an API user will request, you therefore don't know what data to load into memory and return in that object. As EntityGraphQL will execute the field selection against the returned object."),(0,r.kt)("p",null,"Using the ",(0,r.kt)("inlineCode",{parentName:"p"},"Expression<Func<>>")," as a return type allows EntityGraphQL to build an expression across the whole schema graph. An example of the expression result built for the above mutation."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cs"},'(DemoContext ctx) => ctx.People\n    .Where(p => p.Id == <id_from_variable>)\n    .Select(p => new {\n        id = p.Id,\n        firstName = p.FirstName,\n        fullName = $"{p.FirstName} {p.LastName}"\n    })\n    .First()\n')),(0,r.kt)("p",null,"This means we have access to the full schema graph from the core context of the schema and if you are using an ORM like Entity Framework it will load the requested data for you."))}d.isMDXComponent=!0}}]);