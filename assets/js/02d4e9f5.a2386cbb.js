"use strict";(self.webpackChunkentity_graphql_docs=self.webpackChunkentity_graphql_docs||[]).push([[4121],{7961:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>t,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>d});var s=i(5893),r=i(1151);const a={},t="Serialization & Field Naming",o={id:"serialization-naming/serialization-naming",title:"Serialization & Field Naming",description:"GraphQL is case-sensitive. Currently EntityGraphQL will automatically turn field and argument names from UpperCase to camelCase when you use the helper methods to create a schema with the default options. This means your C# code matches what C# code typically looks like and your GraphQL matches the GraphQL norm too.",source:"@site/docs/serialization-naming/serialization-naming.md",sourceDirName:"serialization-naming",slug:"/serialization-naming/",permalink:"/docs/serialization-naming/",draft:!1,unlisted:!1,editUrl:"https://github.com/EntityGraphQL/EntityGraphQL/tree/master/docs/docs/serialization-naming/serialization-naming.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Schema Directives",permalink:"/docs/directives/schema-directives"},next:{title:"Using NewtonSoft JSON",permalink:"/docs/serialization-naming/newtonsoft-json"}},l={},d=[{value:"Serializing Inherited Types",id:"serializing-inherited-types",level:2},{value:"Override default naming",id:"override-default-naming",level:2},{value:"Serialization",id:"serialization",level:2},{value:"Full PascalCase example",id:"full-pascalcase-example",level:2}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"serialization--field-naming",children:"Serialization & Field Naming"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"GraphQL is case-sensitive"}),". Currently EntityGraphQL will automatically turn field and argument names from ",(0,s.jsx)(n.code,{children:"UpperCase"})," to ",(0,s.jsx)(n.code,{children:"camelCase"})," when you use the helper methods to create a schema with the default options. This means your C# code matches what C# code typically looks like and your GraphQL matches the GraphQL norm too."]}),"\n",(0,s.jsx)(n.p,{children:"Examples:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["A mutation method in C# named ",(0,s.jsx)(n.code,{children:"AddMovie"})," will be ",(0,s.jsx)(n.code,{children:"addMovie"})," in the schema"]}),"\n",(0,s.jsxs)(n.li,{children:["A root field entity named ",(0,s.jsx)(n.code,{children:"Movie"})," will be named ",(0,s.jsx)(n.code,{children:"movie"})," in the schema"]}),"\n",(0,s.jsxs)(n.li,{children:["A mutation arguments class (",(0,s.jsx)(n.code,{children:"ActorArgs"}),") with fields ",(0,s.jsx)(n.code,{children:"FirstName"})," & ",(0,s.jsx)(n.code,{children:"Id"})," will be arguments in the schema as ",(0,s.jsx)(n.code,{children:"firstName"})," & ",(0,s.jsx)(n.code,{children:"id"})]}),"\n",(0,s.jsxs)(n.li,{children:["If you're using the schema builder manually, the names you give will be the names used. E.g. ",(0,s.jsx)(n.code,{children:'schemaProvider.AddField("someField", ...)'})," is different to ",(0,s.jsx)(n.code,{children:'schemaProvider.AddField("SomeField", ...)'})]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"serializing-inherited-types",children:"Serializing Inherited Types"}),"\n",(0,s.jsx)(n.p,{children:"In versions prior to .NET 7, System.Text.Json doesn't support the serialization of polymorphic type hierarchies. For example, if a property's type is an interface or an abstract class, only the properties defined on the interface or abstract/union class are serialized, even if the runtime type has additional properties."}),"\n",(0,s.jsxs)(n.p,{children:["For this reason EntityGraphQL registers a RuntimeTypeJsonConverter class as part of the DefaultGraphQLResponseSerializer (credit to litleAndroidMan from ",(0,s.jsx)(n.a,{href:"https://stackoverflow.com/a/71074354/629083",children:"https://stackoverflow.com/a/71074354/629083"}),")."]}),"\n",(0,s.jsx)(n.p,{children:"If you're overriding the DefaultGraphQLResponseSerializer or using System.Text.Json directly you can still use this class by registering it yourself."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cs",children:"this.jsonOptions.Converters.Add(new RuntimeTypeJsonConverter<object>());\n"})}),"\n",(0,s.jsx)(n.p,{children:"You can also disable it by passing in your own jsonOptions when you register/create DefaultGraphQLResponseSerializer."}),"\n",(0,s.jsx)(n.h2,{id:"override-default-naming",children:"Override default naming"}),"\n",(0,s.jsxs)(n.p,{children:["To override the default behavior you can pass in your own ",(0,s.jsx)(n.code,{children:"fieldNamer"})," function when creating the ",(0,s.jsx)(n.code,{children:"SchemaProvider"})," or configuring it."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cs",children:"services.AddGraphQLSchema<DemoContext>(options => {\n    options.FieldNamer = name => name; // use the dotnet name as is\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"Then make sure you follow your naming policy when adding fields to the schema."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cs",children:'services.AddGraphQLSchema<DemoContext>(options => {\n    options.FieldNamer = name => name; // use the dotnet name as is\n    options.ConfigureSchema = schema => {\n        schema.Query().AddField("SomeField", ...)\n    };\n});\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Note that this impacts the names used for fields and arguments in the GraphQL schema and how these are matched to a query. This can impact serialization, but is not serialization."})}),"\n",(0,s.jsxs)(n.p,{children:["An example - our ",(0,s.jsx)(n.code,{children:"DemoContext"})," with the default ",(0,s.jsx)(n.code,{children:"fieldNamer"})," will create this GraphQL schema (trimmed down for the example). Note the ",(0,s.jsx)(n.code,{children:"camelCase"})," naming."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:"schema {\n    query: Query\n}\n\nType Query {\n    people: [Person]\n    person(id: ID!): Person\n}\n\nType Person {\n    id: ID!\n    firstName: String!\n    ...\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"This means queries need to match the casing as GraphQL is case-sensitive."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:"{\n  # will work\n  people {\n    id\n    firstName\n  }\n\n  # will fail\n  People {\n    id\n    firstName\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The above query will generate typed objects ",(0,s.jsx)(n.em,{children:"before serialization"})," with the matching names from the schema. ",(0,s.jsx)(n.em,{children:"Note the types are generated internally as part of compiling, users do not need to use/know them but it demonstrates serialization impact"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cs",children:"public class TempPersonResult\n{\n    // names taken from schema naming - e.g. camelCase\n    public Guid id;\n    public string firstName;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"QueryResult"})," object is a dictionary of root level queries ",(0,s.jsx)(n.code,{children:"{ fieldName: object }"})," and in the above case it would be"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cs",children:'IEnumerable<TempPersonResult> people = ... // implementation is more complex and not shown here - see Entity Framework section for more info\nQueryResult result = ctx => {\n    {"people", people} // key taken from schema file name - camelCase\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"serialization",children:"Serialization"}),"\n",(0,s.jsx)(n.p,{children:"We see how types/fields are named by default above and how to change that. Next you may want to change how data coming in or returned is deserialized or serialized."}),"\n",(0,s.jsxs)(n.p,{children:["You can customize how EntityGraphQL handles de/serialization by registering your own ",(0,s.jsx)(n.code,{children:"IGraphQLResponseSerializer"})," and/or ",(0,s.jsx)(n.code,{children:"IGraphQLRequestDeserializer"}),". Both should be registered before calling ",(0,s.jsx)(n.code,{children:"AddGraphQLSchema()"})," as it adds the default implementations if not already registered."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"IGraphQLRequestDeserializer"})," - Used to deserialize an incoming ",(0,s.jsx)(n.code,{children:"POST"})," body data into a ",(0,s.jsx)(n.code,{children:"QueryRequest"})," object"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"IGraphQLResponseSerializer"})," - Used to serialize a ",(0,s.jsx)(n.code,{children:"QueryResult"})," object into the ",(0,s.jsx)(n.code,{children:"Response"})," stream"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The default implementations try to deserialize JSON into the ",(0,s.jsx)(n.code,{children:"QueryRequest"})," object and serialize the ",(0,s.jsx)(n.code,{children:"QueryResult"})," object to JSON using the following JSON options."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cs",children:"var jsonOptions = new JsonSerializerOptions\n{\n    // the internal generated types use fields so include this\n    IncludeFields = true,\n    PropertyNamingPolicy = JsonNamingPolicy.CamelCase, // match common JSON style and fits with many GraphQL tools\n};\n// Convert ENUMs to their string names\nvar jsonOptions.Converters.Add(new JsonStringEnumConverter());\n"})}),"\n",(0,s.jsxs)(n.p,{children:["You can quickly overwrite the default JSON options without implementing your own ",(0,s.jsx)(n.code,{children:"IGraphQLResponseSerializer"})," and/or ",(0,s.jsx)(n.code,{children:"IGraphQLRequestDeserializer"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cs",children:"var jsonOptions = new JsonSerializerOptions\n{\n    // the internal generated types use fields so include this\n    IncludeFields = true,\n    // leaving out the camelCase option\n};\n// overwrite the JSON options using the DefaultGraphQLResponseSerializer\nservices.AddSingleton<IGraphQLResponseSerializer>(new DefaultGraphQLResponseSerializer(jsonOptions));\nservices.AddGraphQLSchema<DemoContext>();\n"})}),"\n",(0,s.jsx)(n.h2,{id:"full-pascalcase-example",children:"Full PascalCase example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cs",children:"var jsonOptions = new JsonSerializerOptions\n{\n    // the internal generated types use fields so include this\n    IncludeFields = true,\n};\nvar jsonOptions.Converters.Add(new JsonStringEnumConverter());\nservices.AddSingleton<IGraphQLRequestDeserializer>(new DefaultGraphQLRequestDeserializer(jsonOptions));\nservices.AddSingleton<IGraphQLResponseSerializer>(new DefaultGraphQLResponseSerializer(jsonOptions));\n\nservices.AddGraphQLSchema<DemoContext>(options =>\n{\n    options.FieldNamer = name => name;\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"The above expects a JSON request like"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "Query": "query { People { Id FirstName } }"\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"And a JSON result like"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n    "People": [\n        {\n            "Id": "123",\n            "FirstName": "Bob"\n        },\n        ...\n    ]\n}\n'})})]})}function h(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},1151:(e,n,i)=>{i.d(n,{Z:()=>o,a:()=>t});var s=i(7294);const r={},a=s.createContext(r);function t(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);