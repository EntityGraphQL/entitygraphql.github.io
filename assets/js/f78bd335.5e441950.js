"use strict";(self.webpackChunkentity_graphql_docs=self.webpackChunkentity_graphql_docs||[]).push([[5956],{375:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>a,toc:()=>c});var i=t(5893),s=t(1151);const r={sidebar_position:1},o="Entity Framework",a={id:"library-compatibility/entity-framework",title:"Entity Framework",description:"EntityGraphQL is built to work extremely well with EntityFramework. To see how let's first look at what EntityGraphQL does with GraphQL queries.",source:"@site/docs/library-compatibility/entity-framework.md",sourceDirName:"library-compatibility",slug:"/library-compatibility/entity-framework",permalink:"/docs/library-compatibility/entity-framework",draft:!1,unlisted:!1,editUrl:"https://github.com/EntityGraphQL/EntityGraphQL/tree/master/docs/docs/library-compatibility/entity-framework.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Extension Attribute",permalink:"/docs/other-extensibility/extension-attribute"},next:{title:"Caching",permalink:"/docs/library-compatibility/caching"}},l={},c=[{value:"How EntityGraphQL handles services / Resolve&lt;TService&gt;()",id:"how-entitygraphql-handles-services--resolvetservice",level:2}];function h(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"entity-framework",children:"Entity Framework"}),"\n",(0,i.jsx)(n.p,{children:"EntityGraphQL is built to work extremely well with EntityFramework. To see how let's first look at what EntityGraphQL does with GraphQL queries."}),"\n",(0,i.jsx)(n.h1,{id:"examples",children:"Examples"}),"\n",(0,i.jsxs)(n.p,{children:["Using the ",(0,i.jsx)(n.code,{children:"DemoContext"})," and the schema we created from the Getting Started section, lets look at the sample queries."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"query {\n  movie(id: 11) {\n    id\n    name\n  }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"EntityGraphQL parses the GQL document into an internal representation and uses the schema we built to construct a .NET expression. It will look like this."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cs",children:"var expression = (DemoContext ctx, AnonymousType<> args) =>\n    ctx.Movies\n        .Where(movie => movie.Id == args.id)\n        .Select(movie => new {\n            id = movie.Id,\n            name = movie.Name\n        })\n        .FirstOrDefault();\n"})}),"\n",(0,i.jsxs)(n.p,{children:["You can see all we need to execute this expression is an instance of ",(0,i.jsx)(n.code,{children:"DemoContext"})," and the ",(0,i.jsx)(n.code,{children:"args"})," object which is built by EntityGraphQL on parsing of the GQL document. Given those things EntityGraphQL can do similar to this."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cs",children:"var results = expression.Compile().DynamicInvoke(demoContextInstance, argInstance);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Now if your ",(0,i.jsx)(n.code,{children:"DemoContext"})," is built on top of Entity Framework ",(0,i.jsx)(n.code,{children:"DbContext"})," when EntityGraphQL executes the expression EF will take over and do its thing!"]}),"\n",(0,i.jsx)(n.p,{children:"Namely note that EntityGraphQL only selects the fields asked for and therefore EF will also only return the fields we ask for. Meaning no over fetching to the DB either. If your table had many fields and some large ones, they are not selected from the DB unless the API user asks for those fields."}),"\n",(0,i.jsx)(n.p,{children:"Let's look at a more complicated example."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"{\n  movies {\n    id\n    name\n    director {\n      name\n    }\n    writers {\n      name\n    }\n  }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Will result in the following expression."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cs",children:"var expression = (DemoContext ctx) =>\n    ctx.Movies\n        .Select(movie => new {\n            id = movie.Id,\n            name = movie.Name,\n            director = new {\n                name = movie.Director.Name\n            },\n            writers = movie.Writers.Select(writer => new {\n                name = writer.Name\n            })\n        });\n"})}),"\n",(0,i.jsx)(n.p,{children:"Again, EF will take over and fetch your data for you."}),"\n",(0,i.jsxs)(n.p,{children:["You'll note that EntityGraphQL doesn't care what the context is. It could be a object graph 100% held in memory. What does matter is that when the expression executes and resolves something like ",(0,i.jsx)(n.code,{children:"movie.Writers.Select()"})," that the object has the expected data loaded, or like EF can resolve the data."]}),"\n",(0,i.jsxs)(n.p,{children:["Other ORMs built on top of ",(0,i.jsx)(n.code,{children:"LinqProvider"})," and ",(0,i.jsx)(n.code,{children:"IQueryable"})," should also work although have not been tested."]}),"\n",(0,i.jsx)(n.h2,{id:"how-entitygraphql-handles-services--resolvetservice",children:"How EntityGraphQL handles services / Resolve<TService>()"}),"\n",(0,i.jsxs)(n.p,{children:["Since using EntityGraphQL against an Entity Framework Core ",(0,i.jsx)(n.code,{children:"DbContext"})," is supported we handle ",(0,i.jsx)(n.code,{children:"Resolve<TService>()"})," in a way that will work with EF Core (and possibly other IQueryable based ORMs) which allows EF to build an optimal SQL statement. EF core 3.1+ will throw an error by default if it can't translate an expression to SQL. It can't translate the services used in ",(0,i.jsx)(n.code,{children:"Resolve<TService>()"})," to SQL. To support EF 3.1+ performing optimal queries (and selecting only the fields you request) EntityGraphQL builds and executes the expressions in 2 parts."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.em,{children:["This can be disabled by setting the argument ",(0,i.jsx)(n.code,{children:"ExecuteServiceFieldsSeparately"})," when executing to ",(0,i.jsx)(n.code,{children:"false"}),". For example if your core context is an in memory object."]})}),"\n",(0,i.jsxs)(n.p,{children:["If you encounter any issues when using ",(0,i.jsx)(n.code,{children:"Resolve<TService>()"})," on fields and EF Core 3.1+ please raise an issue."]}),"\n",(0,i.jsxs)(n.p,{children:["Example of how EntityGraphQL handles ",(0,i.jsx)(n.code,{children:"Resolve<TService>()"}),", which can help inform how you build/use other services."]}),"\n",(0,i.jsx)(n.p,{children:"Given the following GQL"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"{\n  people {\n    age\n    manager {\n      name\n    }\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Where ",(0,i.jsx)(n.code,{children:"age"})," is defined with a service as"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cs",children:'schema.Type<Person>().AddField("age", "Persons age")\n    .Resolve<AgeService>((person, ager) => ager.GetAge(person.Birthday));\n'})}),"\n",(0,i.jsxs)(n.p,{children:["EntityGraphQL will build an expression query that first selects everything from the base context (",(0,i.jsx)(n.code,{children:"DemoContext"})," in this case) that EF can execute. Then another expression query that runs on top of that result which includes the ",(0,i.jsx)(n.code,{children:"Resolve<TService>()"})," fields. This means EF can optimize your query and return all the data requested (and nothing more) and in memory we then merge that with data from your services."]}),"\n",(0,i.jsx)(n.p,{children:"An example in C# of what this ends up looking like."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cs",children:"var dbResultFunc = (DbContext context) => context.People.Select(p => new {\n    p_Birthday = p.Birthday, // extracted from the Resolve<TService> expression as it is needed in the in-memory resolution\n    manager = new {\n        name = p.Manager.Name\n    }\n})\n.ToList(); // EF will fetch data\nvar dbResult = dbResultFunc(dbContext); // executes the expression\n\n// note dbResult is an anonymous type known at runtime\nvar resultsFunc = (AnonType dbResult, AgeService ager) => dbResult.Select(p => {\n    age = ager.GetAge(p.p_Birthday), // passing in data we selected just for this\n    manager = p.manager // simple selection from the previous result\n})\n.ToList();\nvar results = resultsFunc(dbResult, ager); // execute for the final result\n"})}),"\n",(0,i.jsx)(n.p,{children:"This allows EF Core to make its optimizations and prevent over-fetching of data when using EntityGraphQL against an EF DbContext."}),"\n",(0,i.jsxs)(n.p,{children:["As seen above EntityGraphQL will execute 2 expressions. The first with all data on the main query context (in this case the ",(0,i.jsx)(n.code,{children:"DbContext"}),") without the service fields and the second against the result of that query including the service fields."]}),"\n",(0,i.jsx)(n.p,{children:"To do this EntityGraphQL needs to update the service field expressions. It does that by first extracting all the expressions form a service that relate to the main query context. For example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cs",children:'schema.UpdateType<Floor>(type => {\n  type.AddField("floorUrl", "Current floor url")\n    .Resolve<IFloorUrlService>((floor, srv) => s.BuildFloorPlanUrl(f.SomeRelation.FirstOrDefault().Id));\n});\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Will extract the ",(0,i.jsx)(n.code,{children:"f.SomeRelation.FirstOrDefault().Id"})," expression. That will be fetched in the first expression execution as ",(0,i.jsx)(n.code,{children:"f.SomeRelation_FirstOrDefault___Id = f.SomeRelation.FirstOrDefault().Id"}),". So when we rebuild the final expression to also execute service fields it will update the expression to be ",(0,i.jsx)(n.code,{children:"s.BuildFloorPlanUrl(f.SomeRelation_FirstOrDefault___Id)"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["You may encounter some issues with EF depending on how complex you expressions are. For example pre-6.0 ",(0,i.jsx)(n.a,{href:"https://github.com/dotnet/efcore/issues/23205",children:"this issue"})," will be hit if you traverse through a relation."]}),"\n",(0,i.jsx)(n.p,{children:"It is best to keep the expressions used to pass query context data into a service as simple as you can. Remember, your services can also access the DB context or anything else they need via DI."}),"\n",(0,i.jsx)(n.h1,{id:"linking-entityframework-queries-to-graphql-operations",children:"Linking EntityFramework queries to GraphQL operations"}),"\n",(0,i.jsxs)(n.p,{children:["If you want to better understand which EF query is being run from which GraphQL operation you can use the ",(0,i.jsx)(n.code,{children:"ExecutionOptions.BeforeRootFieldExpressionBuild"})," callback to add the EF ",(0,i.jsx)(n.a,{href:"https://docs.microsoft.com/en-us/ef/core/querying/tags",children:(0,i.jsx)(n.code,{children:"TagWith"})})," extension method to the query. Below is an example using the ",(0,i.jsx)(n.code,{children:"MapGraphQL"})," ASP.NET helper."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c#",children:'app.UseEndpoints(endpoints =>\n{\n    endpoints.MapGraphQL<DemoContext>(options: new ExecutionOptions\n    {\n        BeforeRootFieldExpressionBuild = (exp, op, field) =>\n        {\n            if (exp.Type.IsGenericTypeQueryable())\n                return Expression.Call(typeof(EntityFrameworkQueryableExtensions), nameof(EntityFrameworkQueryableExtensions.TagWith), [exp.Type.GetGenericArguments()[0]], exp, Expression.Constant($"GQL op: {op ?? "n/a"}, field: {field}"));\n            return exp;\n        }\n    });\n});\n'})})]})}function d(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>a,a:()=>o});var i=t(7294);const s={},r=i.createContext(s);function o(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);